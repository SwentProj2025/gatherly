package com.android.gatherly.viewmodel.map

import android.content.Context
import android.content.pm.PackageManager
import android.location.Location
import androidx.core.content.ContextCompat
import com.android.gatherly.model.event.Event
import com.android.gatherly.model.todo.ToDo
import com.android.gatherly.model.todo.ToDoStatus
import com.android.gatherly.ui.map.EPFL_LATLNG
import com.android.gatherly.ui.map.MapViewModel
import com.android.gatherly.viewmodel.FakeEventsRepositoryLocal
import com.android.gatherly.viewmodel.FakeToDosRepositoryLocal
import com.google.android.gms.location.FusedLocationProviderClient
import com.google.android.gms.location.LocationCallback
import com.google.android.gms.location.LocationResult
import com.google.android.gms.maps.model.LatLng
import com.google.android.gms.tasks.Task
import io.mockk.every
import io.mockk.mockk
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.launch
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.UnconfinedTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.resetMain
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.After
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test

// This file contains code generated by an LLM (Claude.ai).

/**
 * Unit tests for [MapViewModel].
 *
 * Tests the ViewModel's ability to filter drawable todos, handle marker interactions, and manage UI
 * state correctly.
 */
class MapViewModelTests {

  private val testDispatcher = StandardTestDispatcher()

  /**
   * Sets up the test environment by replacing the main dispatcher with a test dispatcher. This
   * allows control over coroutine execution during tests.
   */
  @OptIn(ExperimentalCoroutinesApi::class)
  @Before
  fun setup() {
    Dispatchers.setMain(testDispatcher)
  }

  /** Cleans up the test environment by resetting the main dispatcher to its original state. */
  @OptIn(ExperimentalCoroutinesApi::class)
  @After
  fun tearDown() {
    Dispatchers.resetMain()
  }

  /** Test data objects used across multiple test cases. */
  val testObjects = MapViewModelTestsTodos.testedTodos

  // -------------------------------------Todos------------------------------------------------------
  /**
   * Helper function to determine if a todo should be displayed on the map.
   *
   * A todo is drawable if it is not complete and has a valid location.
   *
   * @param todo The todo to check.
   * @return true if the todo is incomplete and has a location, false otherwise.
   */
  fun isDrawable(todo: ToDo): Boolean {
    return todo.status != ToDoStatus.ENDED && todo.location != null
  }

  /**
   * Verifies that [isDrawable] correctly identifies incomplete todos with locations as drawable.
   *
   * Tests two different incomplete todos that have valid locations to ensure the function
   * consistently returns true for this category.
   */
  @Test
  fun isDrawableWorksOn_IncompleteTodoWithLocation() = runTest {
    val expectedResult1 = true
    val actualResult1 = isDrawable(MapViewModelTestsTodos.incompleteTodoWithLocation1)
    assertEquals(expectedResult1, actualResult1)

    val expectedResult2 = true
    val actualResult2 = isDrawable(MapViewModelTestsTodos.incompleteTodoWithLocation2)
    assertEquals(expectedResult2, actualResult2)
  }

  /**
   * Verifies that [isDrawable] correctly identifies complete todos as not drawable.
   *
   * Even though the todo has a valid location, it should not be drawable because it is marked as
   * complete.
   */
  @Test
  fun isDrawableWorksOn_CompleteTodoWithLocation() = runTest {
    val expectedResult = false
    val actualResult = isDrawable(MapViewModelTestsTodos.completeTodoWithLocation)
    assertEquals(expectedResult, actualResult)
  }

  /**
   * Verifies that [isDrawable] correctly identifies todos without locations as not drawable.
   *
   * Even though the todo is incomplete, it should not be drawable because it lacks a valid location
   * to display on the map.
   */
  @Test
  fun isDrawableWorksOn_IncompleteTodoWithoutLocation() = runTest {
    val expectedResult = false
    val actualResult = isDrawable(MapViewModelTestsTodos.incompleteTodoWithoutLocation)
    assertEquals(expectedResult, actualResult)
  }

  /**
   * Verifies that [isDrawable] correctly identifies complete todos without locations as not
   * drawable.
   *
   * This tests the lazy evaluation behavior where the function should return false as soon as it
   * determines the todo is complete, without checking the location.
   */
  @Test
  fun isDrawableWorksOn_CompleteTodoWithoutLocation() = runTest {
    val expectedResult = false
    val actualResult = isDrawable(MapViewModelTestsTodos.completeTodoWithoutLocation)
    assertEquals(expectedResult, actualResult)
  }

  /**
   * Verifies that [MapViewModel] correctly filters and displays only drawable todos.
   *
   * Populates the repository with a mix of complete/incomplete todos with/without locations, then
   * verifies that the ViewModel's UI state contains only the incomplete todos that have valid
   * locations.
   */
  @OptIn(ExperimentalCoroutinesApi::class)
  @Test
  fun getDrawableTodosRetrievesCorrectList() = runTest {
    val todosRepo = FakeToDosRepositoryLocal()
    val eventsRepo = FakeEventsRepositoryLocal()
    for (todo in testObjects) {
      todosRepo.addTodo(todo)
    }

    val vm = MapViewModel(todosRepository = todosRepo, eventsRepository = eventsRepo)
    advanceUntilIdle()

    val expectedList: List<ToDo> =
        listOf(
            MapViewModelTestsTodos.incompleteTodoWithLocation1,
            MapViewModelTestsTodos.incompleteTodoWithLocation2)

    val actualList: List<ToDo> = vm.uiState.value.itemsList.map { it as ToDo }
    assertEquals(expectedList, actualList)
  }

  /**
   * Verifies that tapping a todo marker updates the expanded todo ID in the UI state.
   *
   * This ensures that the ViewModel correctly tracks which marker the user has expanded for
   * displaying additional information.
   */
  @Test
  fun onTodoMarkerTapped_UpdatesExpandedTodoId() = runTest {
    val todosRepo = FakeToDosRepositoryLocal()
    val eventsRepo = FakeEventsRepositoryLocal()
    val vm = MapViewModel(todosRepository = todosRepo, eventsRepository = eventsRepo)

    assertNull(vm.uiState.value.expandedItemId)

    vm.onMarkerTapped("todo1")

    assertEquals("todo1", vm.uiState.value.expandedItemId)
  }

  /**
   * Verifies that dismissing an expanded marker clears the expanded todo ID in the UI state.
   *
   * This ensures that the ViewModel correctly collapses the marker information when the user
   * dismisses or closes the expanded view.
   */
  @Test
  fun onTodoMarkerDismissed_ClearsExpandedTodoId() = runTest {
    val todosRepo = FakeToDosRepositoryLocal()
    val eventsRepo = FakeEventsRepositoryLocal()
    val vm = MapViewModel(todosRepository = todosRepo, eventsRepository = eventsRepo)

    vm.onMarkerTapped("todo1")
    assertEquals("todo1", vm.uiState.value.expandedItemId)

    vm.onMarkerDismissed()

    assertNull(vm.uiState.value.expandedItemId)
  }

  // ------------------------------------Events------------------------------------------------------
  /** Verifies that tapping an event marker updates the expanded event ID in the UI state. */
  @Test
  fun onEventMarkerTappedDismissed_UpdateExpandedId() = runTest {
    val todosRepo = FakeToDosRepositoryLocal()
    val eventsRepo = FakeEventsRepositoryLocal()
    val vm = MapViewModel(todosRepository = todosRepo, eventsRepository = eventsRepo)

    assertNull(vm.uiState.value.expandedItemId)

    vm.onMarkerTapped("upcoming_location")
    assertEquals("upcoming_location", vm.uiState.value.expandedItemId)

    vm.onMarkerDismissed()
    assertEquals(null, vm.uiState.value.expandedItemId)
  }

  /** Verifies that [MapViewModel] correctly filters and displays only drawable events. */
  @OptIn(ExperimentalCoroutinesApi::class)
  @Test
  fun getDrawableEventsRetrievesCorrectList() = runTest {
    val todosRepo = FakeToDosRepositoryLocal()
    val eventsRepo = FakeEventsRepositoryLocal()
    for (event in MapViewModelTestsEvents.testEvents) {
      eventsRepo.addEvent(event)
    }

    val vm = MapViewModel(todosRepository = todosRepo, eventsRepository = eventsRepo)
    advanceUntilIdle()

    vm.changeView()

    val expectedList: List<Event> =
        listOf(
            MapViewModelTestsEvents.upcomingEventWithLocation1,
            MapViewModelTestsEvents.upcomingEventWithLocation2)

    val actualList: List<Event> = vm.uiState.value.itemsList.map { it as Event }
    assertEquals(expectedList, actualList)
  }

  // ----------------------------------View
  // change---------------------------------------------------

  /** Verifies that [MapViewModel] correctly switches from an todo view to a event view and back. */
  @OptIn(ExperimentalCoroutinesApi::class)
  @Test
  fun canChangeViewBetweenTodosAndEvents() = runTest {
    val todoRepo = FakeToDosRepositoryLocal()
    for (todo in MapViewModelTestsTodos.testedTodos) {
      todoRepo.addTodo(todo)
    }

    val eventRepo = FakeEventsRepositoryLocal()
    for (event in MapViewModelTestsEvents.testEvents) {
      eventRepo.addEvent(event)
    }

    val vm = MapViewModel(todosRepository = todoRepo, eventsRepository = eventRepo)
    advanceUntilIdle()

    val expectedTodosList: List<ToDo> =
        listOf(
            MapViewModelTestsTodos.incompleteTodoWithLocation1,
            MapViewModelTestsTodos.incompleteTodoWithLocation2)

    val expectedEventsList: List<Event> =
        listOf(
            MapViewModelTestsEvents.upcomingEventWithLocation1,
            MapViewModelTestsEvents.upcomingEventWithLocation2)

    val actualTodosList: List<ToDo> = vm.uiState.value.itemsList.map { it as ToDo }
    assertEquals(expectedTodosList, actualTodosList)

    vm.changeView()

    val actualEventsList: List<Event> = vm.uiState.value.itemsList.map { it as Event }
    assertEquals(expectedEventsList, actualEventsList)

    vm.changeView()

    val actualTodosListAgain: List<ToDo> = vm.uiState.value.itemsList.map { it as ToDo }
    assertEquals(expectedTodosList, actualTodosListAgain)
  }
/**   * Verifies that consulting a todo item updates the last consulted todo ID and clears the camera
   * position in the UI state.
   */
  @OptIn(ExperimentalCoroutinesApi::class)
  @Test
  fun onItemConsulted_withTodo_setsLastConsultedTodoIdAndNullsCameraPos() =
      runTest(UnconfinedTestDispatcher()) {
        val todosRepo = FakeToDosRepositoryLocal()
        val eventsRepo = FakeEventsRepositoryLocal()
        val vm = MapViewModel(todosRepository = todosRepo, eventsRepository = eventsRepo)
        advanceUntilIdle()

        // Set initial camera position
        vm.initialiseCameraPosition(mockk(relaxed = true))
        advanceUntilIdle()
        assertNotNull(vm.uiState.value.cameraPos)

        vm.onItemConsulted("todo123")

        assertEquals("todo123", vm.uiState.value.lastConsultedTodoId)
        assertNull(vm.uiState.value.lastConsultedEventId)
        assertNull(vm.uiState.value.cameraPos)
      }

  /** Verifies that consulting an event item updates the last consulted event ID and clears the
   * camera position in the UI state.
   */
  @OptIn(ExperimentalCoroutinesApi::class)
  @Test
  fun onItemConsulted_withEvent_setsLastConsultedEventIdAndNullsCameraPos() =
      runTest(UnconfinedTestDispatcher()) {
        val todosRepo = FakeToDosRepositoryLocal()
        val eventsRepo = FakeEventsRepositoryLocal()
        val vm = MapViewModel(todosRepository = todosRepo, eventsRepository = eventsRepo)
        advanceUntilIdle()

        vm.changeView() // Switch to events view

        vm.onItemConsulted("event456")

        assertEquals("event456", vm.uiState.value.lastConsultedEventId)
        assertNull(vm.uiState.value.lastConsultedTodoId)
        assertNull(vm.uiState.value.cameraPos)
      }

  /** Verifies that initializing the camera position updates the camera position in the UI state. */
  @OptIn(ExperimentalCoroutinesApi::class)
  @Test
  fun initializeCameraPosition_updatesCameraPosInUIState() =
      runTest(UnconfinedTestDispatcher()) {
        val todosRepo = FakeToDosRepositoryLocal()
        val eventsRepo = FakeEventsRepositoryLocal()
        val mockContext = mockk<Context>(relaxed = true)
        val vm = MapViewModel(todosRepository = todosRepo, eventsRepository = eventsRepo)
        advanceUntilIdle()

        assertNull(vm.uiState.value.cameraPos)

        vm.initialiseCameraPosition(mockContext)
        advanceUntilIdle()

        assertNotNull(vm.uiState.value.cameraPos)
        assertEquals(EPFL_LATLNG, vm.uiState.value.cameraPos)
      }

  /** Verifies that fetching location to center on returns the last consulted todo's location. */
  @OptIn(ExperimentalCoroutinesApi::class)
  @Test
  fun fetchLocationToCenterOn_withLastConsultedTodo_returnsTodoLocation() =
      runTest(UnconfinedTestDispatcher()) {
        val todosRepo = FakeToDosRepositoryLocal()
        val eventsRepo = FakeEventsRepositoryLocal()
        todosRepo.addTodo(MapViewModelTestsTodos.incompleteTodoWithLocation1)

        val mockContext = mockk<Context>(relaxed = true)
        val vm = MapViewModel(todosRepository = todosRepo, eventsRepository = eventsRepo)
        advanceUntilIdle()

        vm.onItemConsulted(MapViewModelTestsTodos.incompleteTodoWithLocation1.uid)

        val result = vm.fetchLocationToCenterOn(mockContext)

        val expectedLatLng =
            LatLng(
                MapViewModelTestsTodos.testLocation1.latitude,
                MapViewModelTestsTodos.testLocation1.longitude)
        assertEquals(expectedLatLng, result)
      }

  /** Verifies that fetching location to center on returns the last consulted event's location. */
  @OptIn(ExperimentalCoroutinesApi::class)
  @Test
  fun fetchLocationToCenterOn_withLastConsultedEvent_returnsEventLocation() =
      runTest(UnconfinedTestDispatcher()) {
        val todosRepo = FakeToDosRepositoryLocal()
        val eventsRepo = FakeEventsRepositoryLocal()
        eventsRepo.addEvent(MapViewModelTestsEvents.upcomingEventWithLocation1)

        val mockContext = mockk<Context>(relaxed = true)
        val vm = MapViewModel(todosRepository = todosRepo, eventsRepository = eventsRepo)
        advanceUntilIdle()

        vm.changeView() // Switch to events
        vm.onItemConsulted(MapViewModelTestsEvents.upcomingEventWithLocation1.id)

        val result = vm.fetchLocationToCenterOn(mockContext)

        val expectedLatLng =
            LatLng(
                MapViewModelTestsEvents.testLocation1.latitude,
                MapViewModelTestsEvents.testLocation1.longitude)
        assertEquals(expectedLatLng, result)
      }

  /** Verifies that fetching location to center on with no consulted item returns EPFL location. */
  @OptIn(ExperimentalCoroutinesApi::class)
  @Test
  fun fetchLocationToCenterOn_withNoConsultedItem_returnsEPFL() =
      runTest(UnconfinedTestDispatcher()) {
        val todosRepo = FakeToDosRepositoryLocal()
        val eventsRepo = FakeEventsRepositoryLocal()
        val mockContext = mockk<Context>(relaxed = true)

        val vm =
            MapViewModel(
                todosRepository = todosRepo,
                eventsRepository = eventsRepo,
                fusedLocationClient = null)
        advanceUntilIdle()

        val result = vm.fetchLocationToCenterOn(mockContext)

        assertEquals(EPFL_LATLNG, result)
      }

  /** Verifies that fetching location to center on with location permission and no consulted item returns current location. */
  @OptIn(ExperimentalCoroutinesApi::class)
  @Test
  fun fetchLocationToCenterOn_withLocationPermissionAndNoConsultedItem_returnsCurrentLocation() =
      runTest(UnconfinedTestDispatcher()) {
        val todosRepo = FakeToDosRepositoryLocal()
        val eventsRepo = FakeEventsRepositoryLocal()
        val mockContext = mockk<Context>()
        val mockClient = mockk<FusedLocationProviderClient>(relaxed = true)
        val mockTask = mockk<Task<Void>>(relaxed = true)
        val mockLocation = mockk<Location>()

        every {
          ContextCompat.checkSelfPermission(
              mockContext, android.Manifest.permission.ACCESS_FINE_LOCATION)
        } returns PackageManager.PERMISSION_GRANTED

        every { mockLocation.latitude } returns 50.1231
        every { mockLocation.longitude } returns 2.3253

        var capturedCallback: LocationCallback? = null

        every {
          mockClient.requestLocationUpdates(any(), any<LocationCallback>(), isNull())
        } answers
            {
              capturedCallback = secondArg()
              mockTask
            }

        every { mockClient.removeLocationUpdates(any<LocationCallback>()) } returns mockTask

        val locationResult = mockk<LocationResult>(relaxed = true)
        every { locationResult.locations } returns listOf(mockLocation)

        val vm =
            MapViewModel(
                todosRepository = todosRepo,
                eventsRepository = eventsRepo,
                fusedLocationClient = mockClient)

        advanceUntilIdle()

        var result: LatLng? = null
        val job = launch { result = vm.fetchLocationToCenterOn(mockContext) }

        assertNotNull("Callback should have been captured", capturedCallback)
        capturedCallback?.onLocationResult(locationResult)

        advanceUntilIdle()

        val expectedLatLng = LatLng(50.1231, 2.3253)
        assertNotNull(result)
        assertEquals(expectedLatLng, result)
        job.cancel() // cleanup
      }

  /** Verifies that starting and stopping location updates manages the location job without crashing. */
  @OptIn(ExperimentalCoroutinesApi::class)
  @Test
  fun startAndStopLocationUpdates_managesLocationJob() =
      runTest(UnconfinedTestDispatcher()) {
        val todosRepo = FakeToDosRepositoryLocal()
        val eventsRepo = FakeEventsRepositoryLocal()
        val mockClient = mockk<FusedLocationProviderClient>(relaxed = true)
        val mockContext = mockk<Context>(relaxed = true)

        every {
          ContextCompat.checkSelfPermission(
              mockContext, android.Manifest.permission.ACCESS_FINE_LOCATION)
        } returns PackageManager.PERMISSION_GRANTED

        val vm =
            MapViewModel(
                todosRepository = todosRepo,
                eventsRepository = eventsRepo,
                fusedLocationClient = mockClient)
        advanceUntilIdle()

        vm.startLocationUpdates(mockContext)
        advanceUntilIdle()

        vm.stopLocationUpdates()
        advanceUntilIdle()

        // Just verify it doesn't crash
        assertTrue(true)
      }
}
