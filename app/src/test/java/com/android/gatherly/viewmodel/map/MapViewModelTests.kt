package com.android.gatherly.viewmodel.map

import com.android.gatherly.model.event.Event
import com.android.gatherly.model.todo.ToDo
import com.android.gatherly.model.todo.ToDoStatus
import com.android.gatherly.ui.map.MapViewModel
import com.android.gatherly.viewmodel.FakeEventsRepositoryLocal
import com.android.gatherly.viewmodel.FakeToDosRepositoryLocal
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.resetMain
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.After
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test

// This file contains code generated by an LLM (Claude.ai).

/**
 * Unit tests for [MapViewModel].
 *
 * Tests the ViewModel's ability to filter drawable todos, handle marker interactions, and manage UI
 * state correctly.
 */
class MapViewModelTests {

  private val testDispatcher = StandardTestDispatcher()

  /**
   * Sets up the test environment by replacing the main dispatcher with a test dispatcher. This
   * allows control over coroutine execution during tests.
   */
  @OptIn(ExperimentalCoroutinesApi::class)
  @Before
  fun setup() {
    Dispatchers.setMain(testDispatcher)
  }

  /** Cleans up the test environment by resetting the main dispatcher to its original state. */
  @OptIn(ExperimentalCoroutinesApi::class)
  @After
  fun tearDown() {
    Dispatchers.resetMain()
  }

  /** Test data objects used across multiple test cases. */
  val testObjects = MapViewModelTestsTodos.testedTodos

  // -------------------------------------Todos------------------------------------------------------
  /**
   * Helper function to determine if a todo should be displayed on the map.
   *
   * A todo is drawable if it is not complete and has a valid location.
   *
   * @param todo The todo to check.
   * @return true if the todo is incomplete and has a location, false otherwise.
   */
  fun isDrawable(todo: ToDo): Boolean {
    return todo.status != ToDoStatus.ENDED && todo.location != null
  }

  /**
   * Verifies that [isDrawable] correctly identifies incomplete todos with locations as drawable.
   *
   * Tests two different incomplete todos that have valid locations to ensure the function
   * consistently returns true for this category.
   */
  @Test
  fun isDrawableWorksOn_IncompleteTodoWithLocation() = runTest {
    val expectedResult1 = true
    val actualResult1 = isDrawable(MapViewModelTestsTodos.incompleteTodoWithLocation1)
    assertEquals(expectedResult1, actualResult1)

    val expectedResult2 = true
    val actualResult2 = isDrawable(MapViewModelTestsTodos.incompleteTodoWithLocation2)
    assertEquals(expectedResult2, actualResult2)
  }

  /**
   * Verifies that [isDrawable] correctly identifies complete todos as not drawable.
   *
   * Even though the todo has a valid location, it should not be drawable because it is marked as
   * complete.
   */
  @Test
  fun isDrawableWorksOn_CompleteTodoWithLocation() = runTest {
    val expectedResult = false
    val actualResult = isDrawable(MapViewModelTestsTodos.completeTodoWithLocation)
    assertEquals(expectedResult, actualResult)
  }

  /**
   * Verifies that [isDrawable] correctly identifies todos without locations as not drawable.
   *
   * Even though the todo is incomplete, it should not be drawable because it lacks a valid location
   * to display on the map.
   */
  @Test
  fun isDrawableWorksOn_IncompleteTodoWithoutLocation() = runTest {
    val expectedResult = false
    val actualResult = isDrawable(MapViewModelTestsTodos.incompleteTodoWithoutLocation)
    assertEquals(expectedResult, actualResult)
  }

  /**
   * Verifies that [isDrawable] correctly identifies complete todos without locations as not
   * drawable.
   *
   * This tests the lazy evaluation behavior where the function should return false as soon as it
   * determines the todo is complete, without checking the location.
   */
  @Test
  fun isDrawableWorksOn_CompleteTodoWithoutLocation() = runTest {
    val expectedResult = false
    val actualResult = isDrawable(MapViewModelTestsTodos.completeTodoWithoutLocation)
    assertEquals(expectedResult, actualResult)
  }

  /**
   * Verifies that [MapViewModel] correctly filters and displays only drawable todos.
   *
   * Populates the repository with a mix of complete/incomplete todos with/without locations, then
   * verifies that the ViewModel's UI state contains only the incomplete todos that have valid
   * locations.
   */
  @OptIn(ExperimentalCoroutinesApi::class)
  @Test
  fun getDrawableTodosRetrievesCorrectList() = runTest {
    val todosRepo = FakeToDosRepositoryLocal()
    val eventsRepo = FakeEventsRepositoryLocal()
    for (todo in testObjects) {
      todosRepo.addTodo(todo)
    }

    val vm = MapViewModel(todosRepository = todosRepo, eventsRepository = eventsRepo)
    advanceUntilIdle()

    val expectedList: List<ToDo> =
        listOf(
            MapViewModelTestsTodos.incompleteTodoWithLocation1,
            MapViewModelTestsTodos.incompleteTodoWithLocation2)

    val actualList: List<ToDo> = vm.uiState.value.itemsList.map { it as ToDo }
    assertEquals(expectedList, actualList)
  }

  /**
   * Verifies that tapping a todo marker updates the expanded todo ID in the UI state.
   *
   * This ensures that the ViewModel correctly tracks which marker the user has expanded for
   * displaying additional information.
   */
  @Test
  fun onTodoMarkerTapped_UpdatesExpandedTodoId() = runTest {
    val todosRepo = FakeToDosRepositoryLocal()
    val eventsRepo = FakeEventsRepositoryLocal()
    val vm = MapViewModel(todosRepository = todosRepo, eventsRepository = eventsRepo)

    assertNull(vm.uiState.value.expandedItemId)

    vm.onTodoMarkerTapped("todo1")

    assertEquals("todo1", vm.uiState.value.expandedItemId)
  }

  /**
   * Verifies that dismissing an expanded marker clears the expanded todo ID in the UI state.
   *
   * This ensures that the ViewModel correctly collapses the marker information when the user
   * dismisses or closes the expanded view.
   */
  @Test
  fun onTodoMarkerDismissed_ClearsExpandedTodoId() = runTest {
    val todosRepo = FakeToDosRepositoryLocal()
    val eventsRepo = FakeEventsRepositoryLocal()
    val vm = MapViewModel(todosRepository = todosRepo, eventsRepository = eventsRepo)

    vm.onTodoMarkerTapped("todo1")
    assertEquals("todo1", vm.uiState.value.expandedItemId)

    vm.onTodoMarkerDismissed()

    assertNull(vm.uiState.value.expandedItemId)
  }

  // ------------------------------------Events------------------------------------------------------
  /** Verifies that tapping an event marker updates the expanded event ID in the UI state. */
  @Test
  fun onEventMarkerTappedDismissed_UpdateExpandedId() = runTest {
    val todosRepo = FakeToDosRepositoryLocal()
    val eventsRepo = FakeEventsRepositoryLocal()
    val vm = MapViewModel(todosRepository = todosRepo, eventsRepository = eventsRepo)

    assertNull(vm.uiState.value.expandedItemId)

    vm.onTodoMarkerTapped("upcoming_location")
    assertEquals("upcoming_location", vm.uiState.value.expandedItemId)

    vm.onTodoMarkerDismissed()
    assertEquals(null, vm.uiState.value.expandedItemId)
  }

  /** Verifies that [MapViewModel] correctly filters and displays only drawable events. */
  @OptIn(ExperimentalCoroutinesApi::class)
  @Test
  fun getDrawableEventsRetrievesCorrectList() = runTest {
    val todosRepo = FakeToDosRepositoryLocal()
    val eventsRepo = FakeEventsRepositoryLocal()
    for (event in MapViewModelTestsEvents.testEvents) {
      eventsRepo.addEvent(event)
    }

    val vm = MapViewModel(todosRepository = todosRepo, eventsRepository = eventsRepo)
    advanceUntilIdle()

    vm.changeView()

    val expectedList: List<Event> =
        listOf(
            MapViewModelTestsEvents.upcomingEventWithLocation1,
            MapViewModelTestsEvents.upcomingEventWithLocation2)

    val actualList: List<Event> = vm.uiState.value.itemsList.map { it as Event }
    assertEquals(expectedList, actualList)
  }

  // ----------------------------------View
  // change---------------------------------------------------

  /** Verifies that [MapViewModel] correctly switches from an todo view to a event view and back. */
  @OptIn(ExperimentalCoroutinesApi::class)
  @Test
  fun canChangeViewBetweenTodosAndEvents() = runTest {
    val todoRepo = FakeToDosRepositoryLocal()
    for (todo in MapViewModelTestsTodos.testedTodos) {
      todoRepo.addTodo(todo)
    }

    val eventRepo = FakeEventsRepositoryLocal()
    for (event in MapViewModelTestsEvents.testEvents) {
      eventRepo.addEvent(event)
    }

    val vm = MapViewModel(todosRepository = todoRepo, eventsRepository = eventRepo)
    advanceUntilIdle()

    val expectedTodosList: List<ToDo> =
        listOf(
            MapViewModelTestsTodos.incompleteTodoWithLocation1,
            MapViewModelTestsTodos.incompleteTodoWithLocation2)

    val expectedEventsList: List<Event> =
        listOf(
            MapViewModelTestsEvents.upcomingEventWithLocation1,
            MapViewModelTestsEvents.upcomingEventWithLocation2)

    val actualTodosList: List<ToDo> = vm.uiState.value.itemsList.map { it as ToDo }
    assertEquals(expectedTodosList, actualTodosList)

    vm.changeView()

    val actualEventsList: List<Event> = vm.uiState.value.itemsList.map { it as Event }
    assertEquals(expectedEventsList, actualEventsList)

    vm.changeView()

    val actualTodosListAgain: List<ToDo> = vm.uiState.value.itemsList.map { it as ToDo }
    assertEquals(expectedTodosList, actualTodosListAgain)
  }
}
