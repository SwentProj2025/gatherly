package com.android.gatherly.viewmodel.event

import androidx.test.ext.junit.runners.AndroidJUnit4
import com.android.gatherly.model.event.Event
import com.android.gatherly.model.event.EventState
import com.android.gatherly.model.event.EventStatus
import com.android.gatherly.model.event.EventsLocalRepository
import com.android.gatherly.model.event.EventsRepository
import com.android.gatherly.model.group.Group
import com.android.gatherly.model.group.GroupsLocalRepository
import com.android.gatherly.model.group.GroupsRepository
import com.android.gatherly.model.map.FakeNominatimLocationRepository
import com.android.gatherly.model.profile.Profile
import com.android.gatherly.model.profile.ProfileLocalRepository
import com.android.gatherly.model.profile.ProfileRepository
import com.android.gatherly.ui.events.EditEventViewModel
import com.google.firebase.Timestamp
import junit.framework.TestCase.assertNotNull
import kotlin.time.Duration.Companion.seconds
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.resetMain
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.After
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith

// This file contains code generated by an LLM (Claude.ai).

/** Unit tests for the [EditEventsViewModel] class. */
@RunWith(AndroidJUnit4::class)
@OptIn(ExperimentalCoroutinesApi::class)
class EditEventsViewModelTest {

  private val testTimeout = 120.seconds

  // declare viewModel and repositories
  private lateinit var editEventViewModel: EditEventViewModel
  private lateinit var eventsRepository: EventsRepository
  private lateinit var profileRepository: ProfileRepository
  private lateinit var fakeNominatimClient: FakeNominatimLocationRepository
  private lateinit var groupsRepository: GroupsRepository

  // initialize this so that tests control all coroutines and can wait on them
  private val testDispatcher = StandardTestDispatcher()

  @Before
  fun setUp() {
    // so that tests can wait on coroutines
    Dispatchers.setMain(testDispatcher)

    // initialize repos and viewModel
    profileRepository = ProfileLocalRepository()
    eventsRepository = EventsLocalRepository()
    fakeNominatimClient = FakeNominatimLocationRepository()
    groupsRepository = GroupsLocalRepository()

    // fill the profile and events repositories with profiles and event
    fill_repositories()

    editEventViewModel =
        EditEventViewModel(
            profileRepository = profileRepository,
            eventsRepository = eventsRepository,
            groupsRepository = groupsRepository,
            nominatimClient = fakeNominatimClient)

    // set the event to edit
    runTest(testDispatcher, testTimeout) {
      editEventViewModel.setEventValues(event.id)
      advanceUntilIdle()
    }
  }

  @After
  fun tearDown() {
    Dispatchers.resetMain()
  }

  /*----------------------------------------Profiles--------------------------------------------*/
  val profile1: Profile =
      Profile(
          uid = "1",
          name = "Profile1",
          focusSessionIds = emptyList(),
          participatingEventIds = emptyList(),
          groupIds = emptyList(),
          friendUids = emptyList())

  val profile2: Profile =
      Profile(
          uid = "2",
          name = "Profile2",
          focusSessionIds = emptyList(),
          participatingEventIds = emptyList(),
          groupIds = emptyList(),
          friendUids = emptyList())

  val profile3: Profile =
      Profile(
          uid = "3",
          name = "Profile3",
          focusSessionIds = emptyList(),
          participatingEventIds = emptyList(),
          groupIds = emptyList(),
          friendUids = emptyList())

  val participantProfile: Profile =
      Profile(
          uid = "4",
          name = "Participant",
          focusSessionIds = emptyList(),
          participatingEventIds = emptyList(),
          groupIds = emptyList(),
          friendUids = emptyList())

  val ownerProfile: Profile =
      Profile(
          uid = "0",
          name = "Owner",
          focusSessionIds = emptyList(),
          participatingEventIds = emptyList(),
          groupIds = emptyList(),
          friendUids = emptyList())

  val friend1 =
      Profile(
          uid = "friend1",
          username = "alice",
          name = "Alice",
          focusSessionIds = emptyList(),
          participatingEventIds = emptyList(),
          groupIds = emptyList(),
          friendUids = emptyList())

  val friend2 =
      Profile(
          uid = "friend2",
          username = "bob",
          name = "Bob",
          focusSessionIds = emptyList(),
          participatingEventIds = emptyList(),
          groupIds = emptyList(),
          friendUids = emptyList())

  /*----------------------------------------Event-----------------------------------------------*/
  val event: Event =
      Event(
          id = "0",
          title = "Event title",
          description = "Describing this great event",
          creatorName = ownerProfile.name,
          location = null,
          date = Timestamp(1821465600L, 0),
          startTime = Timestamp(1821465600L, 0),
          endTime = Timestamp(1821465660L, 0),
          creatorId = ownerProfile.uid,
          participants = listOf(ownerProfile.uid, participantProfile.uid),
          status = EventStatus.UPCOMING,
          state = EventState.PUBLIC)

  /*-------------------------------------Title tests--------------------------------------------*/
  /** Title accepts a valid string */
  @Test
  fun canEnterEventTitle() {
    runTest(testDispatcher, testTimeout) {
      val titleString = "This is a title!"
      editEventViewModel.updateName(titleString)
      assert(!editEventViewModel.uiState.nameError) { "Entering title should not make an error" }
      assert(editEventViewModel.uiState.name == titleString) { "Entering title should work" }
    }
  }

  /** Title does not accept a blank string */
  @Test
  fun cannotEnterEmptyEventTitle() {
    runTest(testDispatcher, testTimeout) {
      val blankString = " "
      editEventViewModel.updateName(blankString)
      assert(editEventViewModel.uiState.nameError) { "Blank title should be wrong" }
    }
  }

  /*-------------------------------Description tests--------------------------------------------*/
  /** Description accepts valid string */
  @Test
  fun canEnterEventDescription() {
    runTest(testDispatcher, testTimeout) {
      val descriptionString = "This is the description of this very very cool event"
      editEventViewModel.updateDescription(descriptionString)
      assert(!editEventViewModel.uiState.descriptionError) {
        "Entering description should not make an error"
      }
      assert(editEventViewModel.uiState.description == descriptionString) {
        "Entering description should work"
      }
    }
  }

  /** Description does not accept invalid string */
  @Test
  fun cannotEnterEmptyEventDescription() {
    runTest(testDispatcher, testTimeout) {
      val blankString = " "
      editEventViewModel.updateDescription(blankString)
      assert(editEventViewModel.uiState.descriptionError) { "Blank description should be wrong" }
    }
  }

  /*----------------------------------Due date tests--------------------------------------------*/
  /** Due date accepts valid due date */
  @Test
  fun canEnterEventDueDate() {
    runTest(testDispatcher, testTimeout) {
      val dateString = "13/12/2026"
      editEventViewModel.updateDate(dateString)
      assert(!editEventViewModel.uiState.dateError) { "\'13/12/2026\' should not make an error" }
      assert(editEventViewModel.uiState.date == dateString) { "\'13/12/2026\' should work" }
    }
  }

  /** Due date does not accept words due date */
  @Test
  fun cannotEnterInvalidEventDueDate1() {
    runTest(testDispatcher, testTimeout) {
      val dateString = "This date should not work"
      editEventViewModel.updateDate(dateString)
      assert(editEventViewModel.uiState.dateError) {
        "\'This date should not work\' should be wrong"
      }
    }
  }

  /** Due date does not accept empty due date */
  @Test
  fun cannotEnterInvalidEventDueDate2() {
    runTest(testDispatcher, testTimeout) {
      val dateString = ""
      editEventViewModel.updateDate(dateString)
      assert(editEventViewModel.uiState.dateError) { "Empty date should be wrong" }
    }
  }

  /** Due date does not accept inexistent date */
  @Test
  fun cannotEnterInvalidEventDueDate3() {
    runTest(testDispatcher, testTimeout) {
      val dateString = "33/12/2025"
      editEventViewModel.updateDate(dateString)
      assert(editEventViewModel.uiState.dateError) { "\'33/12/2025\' should be wrong" }
    }
  }

  /*--------------------------------Start time tests--------------------------------------------*/
  /** Start time accepts valid time */
  @Test
  fun canEnterEventStartTime() {
    runTest(testDispatcher, testTimeout) {
      val startTimeString = "13:15"
      editEventViewModel.updateStartTime(startTimeString)
      assert(!editEventViewModel.uiState.startTimeError) { "\'13:15\' should work" }
      assert(editEventViewModel.uiState.startTime == startTimeString) { "\'13:15\' should work" }
    }
  }

  /** Start time does not accept words time */
  @Test
  fun cannotEnterInvalidEventStartTime1() {
    runTest(testDispatcher, testTimeout) {
      val startTimeString = "This time should not work"
      editEventViewModel.updateStartTime(startTimeString)
      assert(editEventViewModel.uiState.startTimeError) {
        "\'This time should not work\' should be wrong"
      }
    }
  }

  /** Start time does not accept empty time */
  @Test
  fun cannotEnterInvalidEventStartTime2() {
    runTest(testDispatcher, testTimeout) {
      val startTimeString = ""
      editEventViewModel.updateStartTime(startTimeString)
      assert(editEventViewModel.uiState.startTimeError) { "Empty start time should be wrong" }
    }
  }

  /** Start time does not accept inexistent time */
  @Test
  fun cannotEnterInvalidEventStartTime3() {
    runTest(testDispatcher, testTimeout) {
      val startTimeString = "25:77"
      editEventViewModel.updateStartTime(startTimeString)
      assert(editEventViewModel.uiState.startTimeError) { "\'25:77\' should be wrong" }
    }
  }

  /*----------------------------------End time tests--------------------------------------------*/

  /** Start time does not accept words time */
  @Test
  fun cannotEnterInvalidEventEndTime1() {
    runTest(testDispatcher, testTimeout) {
      val endTimeString = "This time should not work"
      editEventViewModel.updateEndTime(endTimeString)
      assert(editEventViewModel.uiState.endTimeError) {
        "\'This time should not work\' should be wrong"
      }
    }
  }

  /** Start time does not accept empty time */
  @Test
  fun cannotEnterInvalidEventEndTime2() {
    runTest(testDispatcher, testTimeout) {
      val endTimeString = ""
      editEventViewModel.updateEndTime(endTimeString)
      assert(editEventViewModel.uiState.endTimeError) { "Empty end time should be wrong" }
    }
  }

  /** Start time does not accept inexistent time */
  @Test
  fun cannotEnterInvalidEventEndTime3() {
    runTest(testDispatcher, testTimeout) {
      val endTimeString = "25:77"
      editEventViewModel.updateEndTime(endTimeString)
      assert(editEventViewModel.uiState.endTimeError) { "\'25:77\' should be wrong" }
    }
  }

  /*----------------------------------Participant tests-----------------------------------------*/
  /** Entering a participant updates string */
  @Test
  fun canEnterEventParticipant() {
    runTest(testDispatcher, testTimeout) {
      val participantString = "Participant"
      editEventViewModel.updateParticipant(participantString)
      assert(editEventViewModel.uiState.participant == participantString) {
        "\'Participant\' should update the search string"
      }
    }
  }

  /** Searching for profile returns correct profiles */
  @Test
  fun canFindProfiles1() {
    runTest(testDispatcher, testTimeout) {
      val participantString = "Profile"
      editEventViewModel.updateParticipant(participantString)
      assert(participantString == editEventViewModel.uiState.participant) {
        "\'Profile\' should update the search string"
      }

      editEventViewModel.searchProfileByString(participantString)
      // wait for search coroutine to complete
      advanceUntilIdle()

      assert(editEventViewModel.uiState.suggestedProfiles.size == 3) {
        "\'Profile\' should find 3 profiles"
      }
      assert(editEventViewModel.uiState.suggestedProfiles.contains(profile1)) {
        "\'Profile\' should find Profile1"
      }
      assert(editEventViewModel.uiState.suggestedProfiles.contains(profile2)) {
        "\'Profile\' should find Profile2"
      }
      assert(editEventViewModel.uiState.suggestedProfiles.contains(profile3)) {
        "\'Profile\' should find Profile3"
      }
    }
  }

  /** Searching for inexistent profile returns no suggestions */
  @Test
  fun canFindProfiles2() {
    runTest(testDispatcher, testTimeout) {
      val participantString = "Not a profile"
      editEventViewModel.updateParticipant(participantString)
      assert(editEventViewModel.uiState.participant == participantString) {
        "\'Not a profile\' should update the search string"
      }

      editEventViewModel.searchProfileByString(participantString)
      // wait for search coroutine to complete
      advanceUntilIdle()

      assert(editEventViewModel.uiState.suggestedProfiles.isEmpty()) {
        "\'Not a profile\' should find no profiles"
      }
    }
  }

  /** Can add a participant to an event */
  @Test
  fun canAddEventParticipant() {
    runTest(testDispatcher, testTimeout) {
      editEventViewModel.updateParticipant(profile1.name)
      editEventViewModel.addParticipant(profile1)
      assert(editEventViewModel.uiState.participant == profile1.name) {
        "\'Profile1\' should update the search string"
      }
      assert(editEventViewModel.uiState.participants.contains(profile1)) {
        "\'Profile1\' should be in participants"
      }
    }
  }

  /** Cannot add a participant that is already participating */
  @Test
  fun cannotAddParticipatingEventParticipant() {
    runTest(testDispatcher, testTimeout) {
      editEventViewModel.updateParticipant(participantProfile.name)
      editEventViewModel.addParticipant(participantProfile)
      assert(editEventViewModel.uiState.participant == participantProfile.name) {
        "\'Participant\' should update the search string"
      }
      assert(editEventViewModel.uiState.displayToast) {
        "Adding \'Participant\' should display toast"
      }
    }
  }

  /** Can remove a participant of an event */
  @Test
  fun canRemoveEventParticipant() {
    runTest(testDispatcher, testTimeout) {
      editEventViewModel.updateParticipant(participantProfile.name)
      editEventViewModel.deleteParticipant(participantProfile.uid)
      assert(editEventViewModel.uiState.participant == participantProfile.name) {
        "\'Participant\' should update the search string"
      }
      assert(!editEventViewModel.uiState.participants.contains(participantProfile)) {
        "Removing \'Participant\' should work"
      }
    }
  }

  /** Cannot remove a participant that is not participating */
  @Test
  fun cannotRemoveUnparticipatingEventParticipant() {
    runTest(testDispatcher, testTimeout) {
      editEventViewModel.updateParticipant(profile1.name)
      editEventViewModel.deleteParticipant(profile1.uid)
      assert(editEventViewModel.uiState.participant == profile1.name) {
        "\'Profile1\' should update the search string"
      }
      assert(editEventViewModel.uiState.displayToast) {
        "Removing \'Profile1\' should display toast"
      }
    }
  }

  /** The event owner cannot not be a participant to his own event */
  @Test
  fun cannotRemoveEventOwner() {
    runTest(testDispatcher, testTimeout) {
      editEventViewModel.updateParticipant(ownerProfile.name)
      editEventViewModel.addParticipant(ownerProfile)
      assert(editEventViewModel.uiState.participant == ownerProfile.name) {
        "\'Owner\' should update the search string"
      }
      assert(editEventViewModel.uiState.displayToast) { "Removing \'Owner\' should display toast" }
    }
  }

  /*---------------------------------------Saving tests-----------------------------------------*/
  /** Check that modifying the title and saving works */
  @Test
  fun canSaveEvent1() {
    runTest(testDispatcher, testTimeout) {
      editEventViewModel.setEventValues(event.id)
      val modifiedEvent = event.copy(title = "Something else")
      editEventViewModel.updateName(modifiedEvent.title)
      editEventViewModel.saveEvent()
      advanceUntilIdle()

      assert(eventsRepository.getEvent(event.id).title == modifiedEvent.title) {
        "The event is not modified"
      }
    }
  }

  /** Check that modifying the creator name and saving works */
  @Test
  fun canSaveEvent2() {
    runTest(testDispatcher, testTimeout) {
      editEventViewModel.setEventValues(event.id)
      editEventViewModel.saveEvent()
      advanceUntilIdle()

      assert(eventsRepository.getEvent(event.id).creatorName == ownerProfile.name) {
        "The event is not modified"
      }
    }
  }

  /*-------------------------------------Deleting tests-----------------------------------------*/

  /** Can delete the event */
  @Test
  fun canDeleteEvent() {
    runTest(testDispatcher, testTimeout) {
      editEventViewModel.deleteEvent()
      // wait
      advanceUntilIdle()
      assert(editEventViewModel.uiState.backToOverview) {
        "Successfully deleting should go back to overview events"
      }
    }
  }

  /** Test that the factory creates a ViewModel with dependencies */
  @Test
  fun provideFactory_CreatesViewModelWithDependencies() {
    val factory =
        EditEventViewModel.provideFactory(
            profileRepository = profileRepository,
            eventsRepository = eventsRepository,
            nominatimClient = fakeNominatimClient,
            groupsRepository = groupsRepository)

    val viewModel = factory.create(EditEventViewModel::class.java)
    assertNotNull(viewModel)
  }

  /**
   * This function fills the profile repository with the created profiles, and the event repository
   * with the created event
   */
  fun fill_repositories() {
    runTest(testDispatcher, testTimeout) {
      profileRepository.addProfile(profile1)
      profileRepository.addProfile(profile2)
      profileRepository.addProfile(profile3)
      profileRepository.addProfile(participantProfile)
      profileRepository.addProfile(ownerProfile)
      eventsRepository.addEvent(event)
      advanceUntilIdle()
    }
  }

  /** Test that searching groups by name returns filtered groups */
  @Test
  fun searchGroupsNameByString_returnsFilteredGroups() {
    runTest(testDispatcher, testTimeout) {
      val group1 =
          Group(
              "group1",
              name = "Sports Group",
              creatorId = "0",
              description = "",
              memberIds = listOf("0"),
              adminIds = listOf("0"))
      val group2 =
          Group(
              "group2",
              name = "Study Group",
              creatorId = "0",
              description = "",
              memberIds = listOf("0"),
              adminIds = listOf("0"))
      val group3 =
          Group(
              "group3",
              name = "Party Group",
              creatorId = "1",
              description = "",
              memberIds = listOf("1"),
              adminIds = listOf("1"))

      groupsRepository.addGroup(group1)
      groupsRepository.addGroup(group2)
      groupsRepository.addGroup(group3)

      // Update owner profile to have groups
      val updatedOwner = ownerProfile.copy(groupIds = listOf("group1", "group2"))
      profileRepository.updateProfile(updatedOwner)

      editEventViewModel.setEventValues(event.id)
      advanceUntilIdle()

      // Search for groups starting with "Sp"
      editEventViewModel.updateGroup("Sp")
      editEventViewModel.searchGroupsNameByString("Sp")
      advanceUntilIdle()

      assertEquals(1, editEventViewModel.uiState.suggestedGroups.size)
      assertEquals("Sports Group", editEventViewModel.uiState.suggestedGroups[0].name)
    }
  }

  /** Test that updating group updates the group string */
  @Test
  fun updateGroup_updatesGroupString() {
    runTest(testDispatcher, testTimeout) {
      val groupName = "My Group"
      editEventViewModel.updateGroup(groupName)

      assertEquals(groupName, editEventViewModel.uiState.group)
    }
  }

  /** Test that updating a private event to public changes the state */
  @Test
  fun updatePrivateEventToPublicEvent_changesState() {
    runTest(testDispatcher, testTimeout) {
      // First set event to private
      editEventViewModel.setEventValues(event.id)
      advanceUntilIdle()

      // Change state to something else
      val privateEvent = event.copy(state = EventState.PRIVATE_FRIENDS)
      eventsRepository.editEvent(event.id, privateEvent)
      editEventViewModel.setEventValues(event.id)
      advanceUntilIdle()

      assertNotEquals(EventState.PUBLIC, editEventViewModel.uiState.state)

      // Call method
      editEventViewModel.updatePrivateEventToPublicEvent()

      assertEquals(EventState.PUBLIC, editEventViewModel.uiState.state)
    }
  }

  /** Test that searching friends by string returns filtered friends */
  @Test
  fun searchFriendsProfileByString_returnsFilteredFriends() {
    runTest(testDispatcher, testTimeout) {
      profileRepository.addProfile(friend1)
      profileRepository.addProfile(friend2)
      profileRepository.addFriend(friend1.username, ownerProfile.uid)
      profileRepository.addFriend(friend2.username, ownerProfile.uid)

      editEventViewModel.setEventValues(event.id)
      advanceUntilIdle()

      // Search for friends starting with "Al"
      editEventViewModel.searchFriendsProfileByString("Al")
      advanceUntilIdle()

      assertEquals(1, editEventViewModel.uiState.suggestedFriendsProfile.size)
      assertEquals("Alice", editEventViewModel.uiState.suggestedFriendsProfile[0].name)
    }
  }
}
