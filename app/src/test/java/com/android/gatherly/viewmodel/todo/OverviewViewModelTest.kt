package com.android.gatherly.viewmodel.todo

import androidx.test.ext.junit.runners.AndroidJUnit4
import com.android.gatherly.model.profile.ProfileLocalRepository
import com.android.gatherly.model.profile.ProfileRepository
import com.android.gatherly.model.todo.ToDo
import com.android.gatherly.model.todo.ToDoStatus
import com.android.gatherly.model.todo.ToDosLocalRepository
import com.android.gatherly.model.todo.ToDosRepository
import com.android.gatherly.ui.todo.OverviewViewModel
import com.android.gatherly.ui.todo.TodoSortOrder
import com.android.gatherly.utilstest.MockitoUtils
import com.google.firebase.Timestamp
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.delay
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.resetMain
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import kotlinx.coroutines.withContext
import kotlinx.coroutines.withTimeout
import org.junit.After
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith

private const val TIMEOUT = 100_000L
private const val DELAY = 50L

// Portions of the code in this file were generated by an LLM.

/**
 * Integration tests for [com.android.gatherly.ui.todo.OverviewViewModel] using the real Firestore
 * repository (via emulator).
 *
 * These tests verify that todos are correctly loaded, loading states are properly reflected, and
 * repository errors are surfaced to the UI state.
 */
@RunWith(AndroidJUnit4::class)
@OptIn(ExperimentalCoroutinesApi::class)
class OverviewViewModelTest {
  private lateinit var overviewViewModel: OverviewViewModel
  private lateinit var toDosRepository: ToDosRepository
  private lateinit var profileRepository: ProfileRepository
  private lateinit var mockitoUtils: MockitoUtils

  private val testDispatcher = StandardTestDispatcher()

  @Before
  fun setUp() {
    Dispatchers.setMain(testDispatcher)

    toDosRepository = ToDosLocalRepository()
    profileRepository = ProfileLocalRepository()

    // Mock Firebase Auth
    mockitoUtils = MockitoUtils()
    mockitoUtils.chooseCurrentUser("0")

    overviewViewModel = OverviewViewModel(toDosRepository, profileRepository)
  }

  @After
  fun tearDown() {
    Dispatchers.resetMain()
  }

  private fun makeTodo(
      name: String,
      assignee: String = "user",
      description: String = "lorem ipsum",
      ownerId: String = "user123"
  ): ToDo {
    val now = Timestamp.now()
    return ToDo(
        uid = toDosRepository.getNewUid(),
        name = name,
        description = description,
        dueDate = now,
        dueTime = null,
        location = null,
        status = ToDoStatus.ONGOING,
        ownerId = ownerId)
  }

  @OptIn(ExperimentalCoroutinesApi::class)
  @Test
  fun getAllTodos_success_updatesUiStateWithData() =
      runTest(testDispatcher) {
        // Pre-populate repository
        val todo1 = makeTodo("Sample Todo 1")
        val todo2 = makeTodo("Sample Todo 2")
        toDosRepository.addTodo(todo1)
        toDosRepository.addTodo(todo2)

        advanceUntilIdle()
        // Trigger reload
        overviewViewModel.refreshUIState()

        // Wait for repository load
        waitUntilLoaded(overviewViewModel)

        val state = overviewViewModel.uiState.value
        assertFalse("isLoading should be false after load", state.isLoading)
        assertNull("errorMsg should be null on success", state.errorMsg)
        assertEquals(2, state.todos.size)

        val names = state.todos.map { it.name }
        assertTrue("Sample Todo 1" in names)
        assertTrue("Sample Todo 2" in names)
      }

  @Test
  fun getAllTodos_setsLoadingStateDuringFetch() =
      runTest(testDispatcher) {
        overviewViewModel.refreshUIState()

        // Wait for loading to start
        advanceUntilIdle()

        // Then wait for loading to end
        waitUntilLoaded(overviewViewModel)

        val state = overviewViewModel.uiState.value
        assertFalse("Expected isLoading=false after job completion", state.isLoading)
      }

  @Test
  fun getAllTodos_withEmptyRepo_returnsEmptyList() =
      runTest(testDispatcher) {
        // Repository has no data
        overviewViewModel.refreshUIState()

        waitUntilLoaded(overviewViewModel)

        val state = overviewViewModel.uiState.value
        assertTrue(state.todos.isEmpty())
        assertNull(state.errorMsg)
      }

  @Test
  @OptIn(ExperimentalCoroutinesApi::class)
  fun refreshUiState_triggersReloadSuccessfully() =
      runTest(testDispatcher) {
        val todo1 = makeTodo("Initial Todo")
        toDosRepository.addTodo(todo1)

        advanceUntilIdle()

        overviewViewModel.refreshUIState()

        waitUntilLoaded(overviewViewModel)

        val initialCount = overviewViewModel.uiState.value.todos.size
        assertEquals(1, initialCount)

        // Add another todo and refresh again
        val todo2 = makeTodo("Another Todo")
        toDosRepository.addTodo(todo2)

        advanceUntilIdle()

        overviewViewModel.refreshUIState()

        waitUntilLoaded(overviewViewModel)

        val updatedCount = overviewViewModel.uiState.value.todos.size
        assertEquals(2, updatedCount)
      }

  @OptIn(ExperimentalCoroutinesApi::class)
  @Test
  fun onCheckboxChanged_updatesStatusAndRefreshesUiState() =
      runTest(testDispatcher) {
        // create and add a todo
        val todo = makeTodo("Status Change Test")
        toDosRepository.addTodo(todo)

        advanceUntilIdle()

        // Initial load
        overviewViewModel.refreshUIState()
        waitUntilLoaded(overviewViewModel)

        val initial = overviewViewModel.uiState.value.todos.first()
        assertEquals(ToDoStatus.ONGOING, initial.status)

        // update the todo's status
        overviewViewModel.onCheckboxChanged(todo.uid, ToDoStatus.ENDED)

        // Wait for the UI to refresh and reflect the change
        advanceUntilIdle()

        val updatedTodo = overviewViewModel.uiState.value.todos.first { it.uid == todo.uid }
        assertEquals(
            "Expected todo status to be updated to ENDED", ToDoStatus.ENDED, updatedTodo.status)
      }

  @Test
  fun searchTodos_filtersResultsCorrectly() =
      runTest(testDispatcher) {
        val todoA = makeTodo("Lunch with Claire", description = "meet at EPFL")
        val todoB = makeTodo("Buy groceries", description = "milk and bread")
        val todoC = makeTodo("Running", description = "morning run")

        toDosRepository.addTodo(todoA)
        toDosRepository.addTodo(todoB)
        toDosRepository.addTodo(todoC)

        advanceUntilIdle()

        overviewViewModel.refreshUIState()
        waitUntilLoaded(overviewViewModel)

        // WHEN searching for "lunch"
        overviewViewModel.searchTodos("lunch")
        advanceUntilIdle()

        val filtered = overviewViewModel.uiState.value.todos
        assertEquals(1, filtered.size)
        assertEquals(todoA.uid, filtered.first().uid)
      }

  @Test
  fun searchTodos_restoreFullList_whenQueryCleared() =
      runTest(testDispatcher) {
        val todoA = makeTodo("Lunch with Claire")
        val todoB = makeTodo("Buy groceries")

        toDosRepository.addTodo(todoA)
        toDosRepository.addTodo(todoB)

        advanceUntilIdle()
        overviewViewModel.refreshUIState()
        waitUntilLoaded(overviewViewModel)

        // Ensure we start with 2 todos
        assertEquals(2, overviewViewModel.uiState.value.todos.size)

        // WHEN searching something that yields no result
        overviewViewModel.searchTodos("zzzz")
        advanceUntilIdle()
        assertEquals(0, overviewViewModel.uiState.value.todos.size)

        // WHEN clearing the query
        overviewViewModel.searchTodos("")
        advanceUntilIdle()

        // THEN full list should be restored
        val restored = overviewViewModel.uiState.value.todos
        assertEquals(2, restored.size)
      }

  @Test
  fun searchTodos_filtersAgainstFullList_notFilteredResults() =
      runTest(testDispatcher) {
        val todoA = makeTodo("Lunch with Claire")
        val todoB = makeTodo("Lundry")
        val todoC = makeTodo("Groceries")

        toDosRepository.addTodo(todoA)
        toDosRepository.addTodo(todoB)
        toDosRepository.addTodo(todoC)

        advanceUntilIdle()
        overviewViewModel.refreshUIState()
        waitUntilLoaded(overviewViewModel)

        // First search returns Lunch + Laundry
        overviewViewModel.searchTodos("lun")
        advanceUntilIdle()
        assertEquals(2, overviewViewModel.uiState.value.todos.size)

        // Now type something that returns no result
        overviewViewModel.searchTodos("lunx")
        advanceUntilIdle()
        assertEquals(0, overviewViewModel.uiState.value.todos.size)

        // Backspace: "lun"
        overviewViewModel.searchTodos("lun")
        advanceUntilIdle()

        // Should again return Lunch + Laundry â€” not stay empty
        val results = overviewViewModel.uiState.value.todos
        assertEquals(2, results.size)
      }

  @Test
  fun sortOrder_changes_sortListCorrectly() =
      runTest(testDispatcher) {
        val todoA =
            makeTodo("A", description = "", ownerId = "u").copy(dueDate = Timestamp(1000, 0))
        val todoB =
            makeTodo("B", description = "", ownerId = "u").copy(dueDate = Timestamp(5000, 0))
        val todoC =
            makeTodo("C", description = "", ownerId = "u").copy(dueDate = Timestamp(2000, 0))

        toDosRepository.addTodo(todoA)
        toDosRepository.addTodo(todoB)
        toDosRepository.addTodo(todoC)

        advanceUntilIdle()
        overviewViewModel.refreshUIState()
        waitUntilLoaded(overviewViewModel)

        // When sorting by DATE_ASC
        overviewViewModel.setSortOrder(TodoSortOrder.DATE_ASC)
        advanceUntilIdle()

        val asc = overviewViewModel.uiState.value.todos
        assertEquals(listOf(todoA.uid, todoC.uid, todoB.uid), asc.map { it.uid })

        // When sorting by DATE_DESC
        overviewViewModel.setSortOrder(TodoSortOrder.DATE_DESC)
        advanceUntilIdle()

        val desc = overviewViewModel.uiState.value.todos
        assertEquals(listOf(todoB.uid, todoC.uid, todoA.uid), desc.map { it.uid })

        // When sorting by ALPHABETICAL
        overviewViewModel.setSortOrder(TodoSortOrder.ALPHABETICAL)
        advanceUntilIdle()

        val alpha = overviewViewModel.uiState.value.todos
        assertEquals(listOf(todoA.uid, todoB.uid, todoC.uid), alpha.map { it.uid })
      }

  @Test
  fun sorting_persists_after_refresh() =
      runTest(testDispatcher) {
        val todo1 = makeTodo("A")
        val todo2 = makeTodo("B")

        toDosRepository.addTodo(todo1)
        toDosRepository.addTodo(todo2)

        advanceUntilIdle()
        overviewViewModel.refreshUIState()
        waitUntilLoaded(overviewViewModel)

        // Apply alphabetical
        overviewViewModel.setSortOrder(TodoSortOrder.ALPHABETICAL)
        advanceUntilIdle()

        val firstSorted = overviewViewModel.uiState.value.todos
        assertEquals(listOf(todo1.uid, todo2.uid), firstSorted.map { it.uid })

        // Add new todo
        val todo3 = makeTodo("C")
        toDosRepository.addTodo(todo3)
        advanceUntilIdle()

        overviewViewModel.refreshUIState()
        waitUntilLoaded(overviewViewModel)

        val sortedAfterRefresh = overviewViewModel.uiState.value.todos
        assertEquals(listOf(todo1.uid, todo2.uid, todo3.uid), sortedAfterRefresh.map { it.uid })
      }

  @Test
  fun search_and_sort_interact_correctly() =
      runTest(testDispatcher) {
        val todoA = makeTodo("Alpha")
        val todoC = makeTodo("Charlie")
        val todoB = makeTodo("Bravo")

        toDosRepository.addTodo(todoA)
        toDosRepository.addTodo(todoC)
        toDosRepository.addTodo(todoB)

        advanceUntilIdle()
        overviewViewModel.refreshUIState()
        waitUntilLoaded(overviewViewModel)

        overviewViewModel.setSortOrder(TodoSortOrder.ALPHABETICAL)
        advanceUntilIdle()

        overviewViewModel.searchTodos("a")
        advanceUntilIdle()

        val result = overviewViewModel.uiState.value.todos.map { it.name }
        assertEquals(listOf("Alpha", "Bravo", "Charlie"), result)
      }

  private suspend fun waitUntilLoaded(viewModel: OverviewViewModel) {
    withContext(Dispatchers.Default.limitedParallelism(1)) {
      withTimeout(TIMEOUT) {
        while (viewModel.uiState.value.isLoading) {
          delay(DELAY)
        }
      }
    }
  }
}
