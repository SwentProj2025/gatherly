package com.android.gatherly.viewmodel.todo

import androidx.test.ext.junit.runners.AndroidJUnit4
import com.android.gatherly.model.points.PointsLocalRepository
import com.android.gatherly.model.points.PointsRepository
import com.android.gatherly.model.profile.Profile
import com.android.gatherly.model.profile.ProfileLocalRepository
import com.android.gatherly.model.profile.ProfileRepository
import com.android.gatherly.model.todo.ToDo
import com.android.gatherly.model.todo.ToDoStatus
import com.android.gatherly.model.todo.ToDosLocalRepository
import com.android.gatherly.model.todo.ToDosRepository
import com.android.gatherly.model.todoCategory.ToDoCategoryLocalRepository
import com.android.gatherly.model.todoCategory.ToDoCategoryRepository
import com.android.gatherly.ui.todo.OverviewViewModel
import com.android.gatherly.ui.todo.TodoSortOrder
import com.android.gatherly.utilstest.MockitoUtils
import com.google.firebase.Timestamp
import kotlin.time.Duration.Companion.seconds
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.delay
import kotlinx.coroutines.test.UnconfinedTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.resetMain
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import kotlinx.coroutines.withContext
import kotlinx.coroutines.withTimeout
import org.junit.After
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith

private const val TIMEOUT = 100_000L
private const val DELAY = 50L

// Portions of the code in this file were generated by an LLM.

/**
 * Integration tests for [com.android.gatherly.ui.todo.OverviewViewModel] using the real Firestore
 * repository (via emulator).
 *
 * These tests verify that todos are correctly loaded, loading states are properly reflected, and
 * repository errors are surfaced to the UI state.
 */
@RunWith(AndroidJUnit4::class)
@OptIn(ExperimentalCoroutinesApi::class)
class TodoOverviewViewModelTest {
  private lateinit var overviewViewModel: OverviewViewModel
  private lateinit var toDosRepository: ToDosRepository
  private lateinit var profileRepository: ProfileRepository
  private lateinit var pointsRepository: PointsRepository
  private lateinit var mockitoUtils: MockitoUtils
  private lateinit var toDoCategoryRepository: ToDoCategoryRepository

  private val testDispatcher = UnconfinedTestDispatcher()
  private val testTimeout = 120.seconds

  @Before
  fun setUp() {
    Dispatchers.setMain(testDispatcher)

    toDosRepository = ToDosLocalRepository()
    profileRepository = ProfileLocalRepository()
    pointsRepository = PointsLocalRepository()
    toDoCategoryRepository = ToDoCategoryLocalRepository()

    // Mock Firebase Auth
    mockitoUtils = MockitoUtils()
    mockitoUtils.chooseCurrentUser("0")

    overviewViewModel =
        OverviewViewModel(
            toDosRepository, profileRepository, pointsRepository, toDoCategoryRepository)
  }

  @After
  fun tearDown() {
    Dispatchers.resetMain()
  }

  private fun makeTodo(
      name: String,
      assignee: String = "user",
      description: String = "lorem ipsum",
      ownerId: String = "user123"
  ): ToDo {
    val now = Timestamp.now()
    return ToDo(
        uid = toDosRepository.getNewUid(),
        name = name,
        description = description,
        dueDate = now,
        dueTime = null,
        location = null,
        status = ToDoStatus.ONGOING,
        ownerId = ownerId)
  }

  /** Test that loading todos successfully updates UI state with data. */
  @Test
  fun getAllTodos_success_updatesUiStateWithData() =
      runTest(testDispatcher, testTimeout) {
        // Pre-populate repository
        val todo1 = makeTodo("Sample Todo 1")
        val todo2 = makeTodo("Sample Todo 2")
        toDosRepository.addTodo(todo1)
        toDosRepository.addTodo(todo2)

        advanceUntilIdle()
        // Trigger reload
        overviewViewModel.refreshUIState()

        // Wait for repository load
        waitUntilLoaded(overviewViewModel)

        val state = overviewViewModel.uiState.value
        assertFalse("isLoading should be false after load", state.isLoading)
        assertNull("errorMsg should be null on success", state.errorMsg)
        assertEquals(2, state.todos.size)

        val names = state.todos.map { it.name }
        assertTrue("Sample Todo 1" in names)
        assertTrue("Sample Todo 2" in names)
      }

  /** Test that loading state is set correctly during fetch. */
  @Test
  fun getAllTodos_setsLoadingStateDuringFetch() =
      runTest(testDispatcher, testTimeout) {
        overviewViewModel.refreshUIState()

        // Wait for loading to start
        advanceUntilIdle()

        // Then wait for loading to end
        waitUntilLoaded(overviewViewModel)

        val state = overviewViewModel.uiState.value
        assertFalse("Expected isLoading=false after job completion", state.isLoading)
      }

  /** Test that loading from an empty repository returns an empty list. */
  @Test
  fun getAllTodos_withEmptyRepo_returnsEmptyList() =
      runTest(testDispatcher, testTimeout) {
        // Repository has no data
        overviewViewModel.refreshUIState()

        waitUntilLoaded(overviewViewModel)

        val state = overviewViewModel.uiState.value
        assertTrue(state.todos.isEmpty())
        assertNull(state.errorMsg)
      }

  /** Test that refreshing UI state triggers reload successfully. */
  @Test
  fun refreshUiState_triggersReloadSuccessfully() =
      runTest(testDispatcher, testTimeout) {
        val todo1 = makeTodo("Initial Todo")
        toDosRepository.addTodo(todo1)

        advanceUntilIdle()

        overviewViewModel.refreshUIState()

        waitUntilLoaded(overviewViewModel)

        val initialCount = overviewViewModel.uiState.value.todos.size
        assertEquals(1, initialCount)

        // Add another todo and refresh again
        val todo2 = makeTodo("Another Todo")
        toDosRepository.addTodo(todo2)

        advanceUntilIdle()

        overviewViewModel.refreshUIState()

        waitUntilLoaded(overviewViewModel)
        delay(500) // wait for state propagation

        val updatedCount = overviewViewModel.uiState.value.todos.size
        assertEquals(2, updatedCount)
      }

  /** Test that changing checkbox status updates the todo and refreshes UI state. */
  @Test
  fun onCheckboxChanged_updatesStatusAndRefreshesUiState() =
      runTest(testDispatcher, testTimeout) {
        // create and add a todo
        val todo = makeTodo("Status Change Test")
        toDosRepository.addTodo(todo)

        profileRepository.addProfile(
            Profile(uid = "user123", name = "Test User", profilePicture = ""))

        advanceUntilIdle()

        // Initial load
        overviewViewModel.refreshUIState()
        advanceUntilIdle()

        val initial = overviewViewModel.uiState.value.todos.first()
        assertEquals(ToDoStatus.ONGOING, initial.status)

        // update the todo's status
        overviewViewModel.onCheckboxChanged(todo.uid, ToDoStatus.ENDED)

        // Wait for the UI to refresh and reflect the change
        advanceUntilIdle()
        delay(500) // wait for state propagation

        val updatedTodo = overviewViewModel.uiState.value.todos.first { it.uid == todo.uid }
        assertEquals(
            "Expected todo status to be updated to ENDED", ToDoStatus.ENDED, updatedTodo.status)
      }

  /** Test that searching todos filters results correctly. */
  @Test
  fun searchTodos_filtersResultsCorrectly() =
      runTest(testDispatcher, testTimeout) {
        val todoA = makeTodo("Lunch with Claire", description = "meet at EPFL")
        val todoB = makeTodo("Buy groceries", description = "milk and bread")
        val todoC = makeTodo("Running", description = "morning run")

        toDosRepository.addTodo(todoA)
        toDosRepository.addTodo(todoB)
        toDosRepository.addTodo(todoC)

        advanceUntilIdle()

        overviewViewModel.refreshUIState()
        waitUntilLoaded(overviewViewModel)

        // WHEN searching for "lunch"
        overviewViewModel.searchTodos("lunch")
        advanceUntilIdle()
        delay(500) // wait for state propagation

        val filtered = overviewViewModel.uiState.value.todos
        assertEquals(1, filtered.size)
        assertEquals(todoA.uid, filtered.first().uid)
      }

  /** Test that clearing search query restores the full list. */
  @Test
  fun searchTodos_restoreFullList_whenQueryCleared() =
      runTest(testDispatcher, testTimeout) {
        val todoA = makeTodo("Lunch with Claire")
        val todoB = makeTodo("Buy groceries")

        toDosRepository.addTodo(todoA)
        toDosRepository.addTodo(todoB)

        advanceUntilIdle()
        overviewViewModel.refreshUIState()
        waitUntilLoaded(overviewViewModel)

        // Ensure we start with 2 todos
        assertEquals(2, overviewViewModel.uiState.value.todos.size)

        // WHEN searching something that yields no result
        overviewViewModel.searchTodos("zzzz")
        advanceUntilIdle()
        delay(500) // wait for state propagation
        assertEquals(0, overviewViewModel.uiState.value.todos.size)

        // WHEN clearing the query
        overviewViewModel.searchTodos("")
        advanceUntilIdle()
        delay(500)

        // THEN full list should be restored
        val restored = overviewViewModel.uiState.value.todos
        assertEquals(2, restored.size)
      }

  /** Test that search filters against full list, not previously filtered results. */
  @Test
  fun searchTodos_filtersAgainstFullList_notFilteredResults() =
      runTest(testDispatcher, testTimeout) {
        val todoA = makeTodo("Lunch with Claire")
        val todoB = makeTodo("Lundry")
        val todoC = makeTodo("Groceries")

        toDosRepository.addTodo(todoA)
        toDosRepository.addTodo(todoB)
        toDosRepository.addTodo(todoC)

        advanceUntilIdle()
        overviewViewModel.refreshUIState()
        waitUntilLoaded(overviewViewModel)

        // First search returns Lunch + Laundry
        overviewViewModel.searchTodos("lun")
        advanceUntilIdle()
        delay(500) // wait for state propagation
        assertEquals(2, overviewViewModel.uiState.value.todos.size)

        // Now type something that returns no result
        overviewViewModel.searchTodos("lunx")
        advanceUntilIdle()
        delay(500)
        assertEquals(0, overviewViewModel.uiState.value.todos.size)

        // Backspace: "lun"
        overviewViewModel.searchTodos("lun")
        advanceUntilIdle()
        delay(500)

        // Should again return Lunch + Laundry â€” not stay empty
        val results = overviewViewModel.uiState.value.todos
        assertEquals(2, results.size)
      }

  /** Test that changing sort order sorts the list correctly. */
  @Test
  fun sortOrder_changes_sortListCorrectly() =
      runTest(testDispatcher, testTimeout) {
        val todoA =
            makeTodo("A", description = "", ownerId = "u").copy(dueDate = Timestamp(1000, 0))
        val todoB =
            makeTodo("B", description = "", ownerId = "u").copy(dueDate = Timestamp(5000, 0))
        val todoC =
            makeTodo("C", description = "", ownerId = "u").copy(dueDate = Timestamp(2000, 0))

        toDosRepository.addTodo(todoA)
        toDosRepository.addTodo(todoB)
        toDosRepository.addTodo(todoC)

        advanceUntilIdle()
        overviewViewModel.refreshUIState()
        waitUntilLoaded(overviewViewModel)

        // When sorting by DATE_ASC
        overviewViewModel.setSortOrder(TodoSortOrder.DATE_ASC)
        advanceUntilIdle()
        delay(500)

        val asc = overviewViewModel.uiState.value.todos
        assertEquals(listOf(todoA.uid, todoC.uid, todoB.uid), asc.map { it.uid })

        // When sorting by DATE_DESC
        overviewViewModel.setSortOrder(TodoSortOrder.DATE_DESC)
        advanceUntilIdle()
        delay(500)

        val desc = overviewViewModel.uiState.value.todos
        assertEquals(listOf(todoB.uid, todoC.uid, todoA.uid), desc.map { it.uid })

        // When sorting by ALPHABETICAL
        overviewViewModel.setSortOrder(TodoSortOrder.ALPHABETICAL)
        advanceUntilIdle()
        delay(500)

        val alpha = overviewViewModel.uiState.value.todos
        assertEquals(listOf(todoA.uid, todoB.uid, todoC.uid), alpha.map { it.uid })
      }

  /** Test that sorting persists after refresh. */
  @Test
  fun sorting_persists_after_refresh() =
      runTest(testDispatcher, testTimeout) {
        val todo1 = makeTodo("A")
        val todo2 = makeTodo("B")

        toDosRepository.addTodo(todo1)
        toDosRepository.addTodo(todo2)

        advanceUntilIdle()
        overviewViewModel.refreshUIState()
        waitUntilLoaded(overviewViewModel)

        // Apply alphabetical
        overviewViewModel.setSortOrder(TodoSortOrder.ALPHABETICAL)
        advanceUntilIdle()

        val firstSorted = overviewViewModel.uiState.value.todos
        assertEquals(listOf(todo1.uid, todo2.uid), firstSorted.map { it.uid })

        // Add new todo
        val todo3 = makeTodo("C")
        toDosRepository.addTodo(todo3)
        advanceUntilIdle()

        overviewViewModel.refreshUIState()
        waitUntilLoaded(overviewViewModel)
        delay(500) // wait for state propagation

        val sortedAfterRefresh = overviewViewModel.uiState.value.todos
        assertEquals(listOf(todo1.uid, todo2.uid, todo3.uid), sortedAfterRefresh.map { it.uid })
      }

  /** Test that search and sort interact correctly. */
  @Test
  fun search_and_sort_interact_correctly() =
      runTest(testDispatcher, testTimeout) {
        val todoA = makeTodo("Alpha")
        val todoC = makeTodo("Charlie")
        val todoB = makeTodo("Bravo")

        toDosRepository.addTodo(todoA)
        toDosRepository.addTodo(todoC)
        toDosRepository.addTodo(todoB)

        advanceUntilIdle()
        overviewViewModel.refreshUIState()
        waitUntilLoaded(overviewViewModel)

        overviewViewModel.setSortOrder(TodoSortOrder.ALPHABETICAL)
        advanceUntilIdle()

        overviewViewModel.searchTodos("a")
        advanceUntilIdle()
        delay(500)

        val result = overviewViewModel.uiState.value.todos.map { it.name }
        assertEquals(listOf("Alpha", "Bravo", "Charlie"), result)
      }

  private suspend fun waitUntilLoaded(viewModel: OverviewViewModel) {
    withContext(Dispatchers.Default.limitedParallelism(1)) {
      withTimeout(TIMEOUT) {
        while (viewModel.uiState.value.isLoading) {
          delay(DELAY)
        }
      }
    }
  }
}
