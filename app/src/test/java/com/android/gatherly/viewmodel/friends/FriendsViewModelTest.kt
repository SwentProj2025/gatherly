package com.android.gatherly.viewmodel.friends

import com.android.gatherly.model.notification.NotificationType
import com.android.gatherly.model.notification.NotificationsLocalRepository
import com.android.gatherly.model.notification.NotificationsRepository
import com.android.gatherly.model.points.PointsLocalRepository
import com.android.gatherly.model.points.PointsRepository
import com.android.gatherly.model.profile.ProfileLocalRepository
import com.android.gatherly.ui.friends.FriendsViewModel
import com.android.gatherly.utilstest.MockitoUtils
import com.android.gatherly.viewmodel.friends.FriendsViewModelTestsData.USER_A_ID
import com.android.gatherly.viewmodel.friends.FriendsViewModelTestsData.USER_A_USERNAME
import com.android.gatherly.viewmodel.friends.FriendsViewModelTestsData.USER_B_ID
import com.android.gatherly.viewmodel.friends.FriendsViewModelTestsData.USER_B_USERNAME
import com.android.gatherly.viewmodel.friends.FriendsViewModelTestsData.USER_C_ID
import com.android.gatherly.viewmodel.friends.FriendsViewModelTestsData.USER_C_USERNAME
import com.android.gatherly.viewmodel.friends.FriendsViewModelTestsData.anon
import com.android.gatherly.viewmodel.friends.FriendsViewModelTestsData.createErrorThrowingProfileRepository
import com.android.gatherly.viewmodel.friends.FriendsViewModelTestsData.userA
import com.android.gatherly.viewmodel.friends.FriendsViewModelTestsData.userB
import com.android.gatherly.viewmodel.friends.FriendsViewModelTestsData.userC
import kotlin.time.Duration.Companion.seconds
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.test.UnconfinedTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.resetMain
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.After
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test

// This file contains code generated by an LLM (Claude.ai).

/**
 * Integration tests for [FriendsViewModel] using the local Emulators.
 *
 * These tests verify:
 * - Initial state of friends list
 * - When following a friend, the list is updated accordingly
 * - When unfollowing a friend, the list is updated accordingly
 */
@OptIn(ExperimentalCoroutinesApi::class)
class FriendsViewModelTest {

  private lateinit var profileRepository: ProfileLocalRepository
  private lateinit var notificationsRepository: NotificationsRepository
  private lateinit var pointsRepository: PointsRepository
  private lateinit var viewModel: FriendsViewModel
  private lateinit var mockitoUtils: MockitoUtils

  // initialize this so that tests control all coroutines and can wait on them
  private val testDispatcher = UnconfinedTestDispatcher()
  val testTimeout = 120.seconds

  @Before
  fun setUp() {
    // so that tests can wait on coroutines
    Dispatchers.setMain(testDispatcher)
    // initialize repos and viewModel
    profileRepository = ProfileLocalRepository()
    notificationsRepository = NotificationsLocalRepository()
    pointsRepository = PointsLocalRepository()

    fill_repositories()

    // Mock Firebase Auth
    mockitoUtils = MockitoUtils()
    mockitoUtils.chooseCurrentUser(USER_A_ID)

    viewModel =
        FriendsViewModel(
            repository = profileRepository,
            notificationsRepository = notificationsRepository,
            pointsRepository = pointsRepository,
            authProvider = { mockitoUtils.mockAuth })
  }

  @After
  fun tearDown() {
    Dispatchers.resetMain()
  }

  /** Verifies that the initial state contains the correct friends and non-friends lists. */
  @Test
  fun testInitialStateShouldContainEachFriends() =
      runTest(testDispatcher, testTimeout) {
        val state = viewModel.uiState.value
        assertEquals(listOf("bob"), state.friends)
        assertTrue(state.listNoFriends.contains("charlie"))
        assertFalse(state.listNoFriends.contains(""))
      }

  /** Verifies that following a new friend updates the friends list correctly. */
  @Test
  fun testFollowFriendCFromProfileA() =
      runTest(testDispatcher, testTimeout) {
        viewModel.followFriend(USER_C_USERNAME, USER_A_ID)

        advanceUntilIdle()

        val state = viewModel.uiState.value
        assertTrue(state.friends.contains(USER_C_USERNAME))
      }

  /** Verifies that unfollowing an existing friend removes them from the friends list. */
  @Test
  fun testUnfollowFriendBFromProfileA() =
      runTest(testDispatcher, testTimeout) {
        viewModel.unfollowFriend(USER_B_USERNAME, USER_A_ID)

        advanceUntilIdle()

        val state = viewModel.uiState.value
        assertFalse(state.friends.contains(USER_B_USERNAME))
      }

  /** Fills the profile repository with test profiles. */
  private fun fill_repositories() {
    runBlocking {
      profileRepository.addProfile(userA)
      profileRepository.addProfile(userB)
      profileRepository.addProfile(userC)
      profileRepository.addProfile(anon)
    }
  }

  /** Verifies that refreshFriends catches exceptions and sets an error message. */
  @Test
  fun testRefreshFriends_CatchesExceptionAndSetsErrorMsg() =
      runTest(testDispatcher, testTimeout) {
        val errorMessage = "Simulated Connection Failure"

        val throwingRepository = createErrorThrowingProfileRepository(errorMessage)

        val errorViewModel =
            FriendsViewModel(
                repository = throwingRepository,
                notificationsRepository = notificationsRepository,
                pointsRepository = pointsRepository,
                authProvider = { mockitoUtils.mockAuth })
        errorViewModel.refreshFriends(USER_A_ID)

        advanceUntilIdle()
        val state = errorViewModel.uiState.value

        assertNotNull(state.errorMsg)
        assertTrue(state.errorMsg!!.contains("Failed to load friends: $errorMessage"))
        assertTrue(state.friends.isEmpty())
        assertTrue(state.listNoFriends.isEmpty())
      }

  /** Verifies that sending a friend request adds pending status and creates a notification. */
  @Test
  fun testSendFriendRequest_addsPendingAndNotification() =
      runTest(testDispatcher, testTimeout) {
        viewModel.sendFriendRequest(USER_C_ID, USER_A_ID)
        advanceUntilIdle()

        val state = viewModel.uiState.value

        assertTrue(state.pendingSentUsernames.contains(USER_C_USERNAME))

        val userAProfile = profileRepository.getProfileByUid(USER_A_ID)!!
        assertTrue(userAProfile.pendingSentFriendsUids.contains(USER_C_ID))

        val notifications = notificationsRepository.getUserNotifications(USER_C_ID)
        assertEquals(1, notifications.size)
        assertEquals(NotificationType.FRIEND_REQUEST, notifications.first().type)
        assertEquals(USER_A_ID, notifications.first().senderId)
      }

  /** Verifies that sending duplicate friend requests does not create duplicate pending status. */
  @Test
  fun testSendFriendRequest_doesNotDuplicatePending() =
      runTest(testDispatcher, testTimeout) {
        viewModel.sendFriendRequest(USER_C_ID, USER_A_ID)
        advanceUntilIdle()

        viewModel.sendFriendRequest(USER_C_ID, USER_A_ID)
        advanceUntilIdle()

        val userAProfile = profileRepository.getProfileByUid(USER_A_ID)!!
        assertEquals(1, userAProfile.pendingSentFriendsUids.size)

        val notifications = notificationsRepository.getUserNotifications(USER_C_ID)
        assertEquals(1, notifications.size)
      }

  /** Verifies that sending a friend request to a non-existent profile fails with error message. */
  @Test
  fun testSendFriendRequest_failsIfProfileMissing() =
      runTest(testDispatcher, testTimeout) {
        viewModel.sendFriendRequest("UNKNOWN", USER_A_ID)
        advanceUntilIdle()

        val state = viewModel.uiState.value
        assertEquals("Friend profile not found", state.errorMsg)
      }

  /** Verifies that removing a friend updates the friends list and sends a notification. */
  @Test
  fun testRemoveFriend_removesAndSendsNotification() =
      runTest(testDispatcher, testTimeout) {
        assertTrue(viewModel.uiState.value.friends.contains(USER_B_USERNAME))

        viewModel.removeFriend(USER_B_ID, USER_A_ID)
        advanceUntilIdle()

        val state = viewModel.uiState.value
        assertFalse(state.friends.contains(USER_B_USERNAME))

        val notifications = notificationsRepository.getUserNotifications(USER_B_ID)
        assertEquals(1, notifications.size)
        assertEquals(NotificationType.REMOVE_FRIEND, notifications.first().type)
      }

  /** Verifies that attempting to remove a non-friend results in an error message. */
  @Test
  fun testRemoveFriend_errorsIfNotFriend() =
      runTest(testDispatcher, testTimeout) {
        viewModel.removeFriend(USER_C_ID, USER_A_ID)
        advanceUntilIdle()

        val state = viewModel.uiState.value
        assertEquals("Cannot remove non-friend", state.errorMsg)
      }

  /**
   * Verifies that canceling a pending friend request removes pending status and sends notification.
   */
  @Test
  fun testCancelPendingFriendRequest_cancelsCorrectly() =
      runTest(testDispatcher, testTimeout) {
        viewModel.sendFriendRequest(USER_C_ID, USER_A_ID)
        advanceUntilIdle()

        viewModel.cancelPendingFriendRequest(USER_C_ID, USER_A_ID)
        advanceUntilIdle()

        val userAProfile = profileRepository.getProfileByUid(USER_A_ID)!!
        assertFalse(userAProfile.pendingSentFriendsUids.contains(USER_C_ID))

        val notifications = notificationsRepository.getUserNotifications(USER_C_ID)

        assertEquals(2, notifications.size)
        assertTrue(
            notifications.any {
              it.type == NotificationType.FRIEND_REQUEST &&
                  it.senderId == USER_A_ID &&
                  it.recipientId == USER_C_ID
            })
        assertTrue(
            notifications.any {
              it.type == NotificationType.FRIEND_REQUEST_CANCELLED &&
                  it.senderId == USER_A_ID &&
                  it.recipientId == USER_C_ID
            })
      }

  /** Verifies that refreshFriends correctly populates all state fields including profiles map. */
  @Test
  fun testRefreshFriends_populatesStateCorrectly() =
      runTest(testDispatcher, testTimeout) {
        viewModel.refreshFriends(USER_A_ID)
        advanceUntilIdle()

        val state = viewModel.uiState.value

        assertEquals(USER_A_ID, state.currentUserId)
        assertTrue(state.friends.contains(USER_B_USERNAME))
        assertTrue(state.listNoFriends.contains(USER_C_USERNAME))

        assertNotNull(state.profiles[USER_B_USERNAME])
        assertNotNull(state.profiles[USER_C_USERNAME])
        assertFalse(state.profiles.containsKey(USER_A_USERNAME))

        assertFalse(state.isLoading)
      }
}
