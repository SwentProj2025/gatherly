package com.android.gatherly.viewmodel

import com.android.gatherly.model.todo.BootcampToDo
import com.android.gatherly.model.todo.BootcampToDosRepositoryLocal
import com.android.gatherly.model.todo.isDrawable
import com.android.gatherly.ui.map.MapViewModel
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.resetMain
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.After
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test

// This file contains code generated by an LLM (Claude.ai).

class MapViewModelTests {

  private val testDispatcher = StandardTestDispatcher()

  @OptIn(ExperimentalCoroutinesApi::class)
  @Before
  fun setup() {
    Dispatchers.setMain(testDispatcher)
  }

  @OptIn(ExperimentalCoroutinesApi::class)
  @After
  fun tearDown() {
    Dispatchers.resetMain()
  }

  val testObjects = MapViewModelTestsTodos.testedTodos

  @Test
  fun isDrawableWorksOn_IncompleteTodoWithLocation() = runTest {
    // Should be drawable as todos are incomplete and have location
    val expectedResult1 = true
    val actualResult1 = MapViewModelTestsTodos.incompleteTodoWithLocation1.isDrawable()
    assertEquals(expectedResult1, actualResult1)

    val expectedResult2 = true
    val actualResult2 = MapViewModelTestsTodos.incompleteTodoWithLocation2.isDrawable()
    assertEquals(expectedResult2, actualResult2)
  }

  @Test
  fun isDrawableWorksOn_CompleteTodoWithLocation() = runTest {
    // Should not be drawable as todo is complete
    val expectedResult = false
    val actualResult = MapViewModelTestsTodos.completeTodoWithLocation.isDrawable()
    assertEquals(expectedResult, actualResult)
  }

  @Test
  fun isDrawableWorksOn_IncompleteTodoWithoutLocation() = runTest {
    // Should not be drawable as todo has no location
    val expectedResult = false
    val actualResult = MapViewModelTestsTodos.incompleteTodoWithoutLocation.isDrawable()
    assertEquals(expectedResult, actualResult)
  }

  @Test
  fun isDrawableWorksOn_CompleteTodoWithoutLocation() = runTest {
    // Should not be drawable as todo is complete (lazy evaluation)
    val expectedResult = false
    val actualResult = MapViewModelTestsTodos.completeTodoWithoutLocation.isDrawable()
    assertEquals(expectedResult, actualResult)
  }

  @OptIn(ExperimentalCoroutinesApi::class)
  @Test
  fun getDrawableTodosRetrievesCorrectList() = runTest {
    val repo = BootcampToDosRepositoryLocal()
    for (todo in testObjects) {
      repo.addTodo(todo)
    }

    val vm = MapViewModel(repo)
    advanceUntilIdle()

    val expectedList: List<BootcampToDo> =
        listOf(
            MapViewModelTestsTodos.incompleteTodoWithLocation1,
            MapViewModelTestsTodos.incompleteTodoWithLocation2)

    val actualList: List<BootcampToDo> = vm.uiState.value.todoList
    assertEquals(expectedList, actualList)
  }

  @Test
  fun onTodoMarkerTapped_UpdatesExpandedTodoId() = runTest {
    val repo = BootcampToDosRepositoryLocal()
    val vm = MapViewModel(repo)

    assertNull(vm.uiState.value.expandedTodoId)

    vm.onTodoMarkerTapped("todo1")

    assertEquals("todo1", vm.uiState.value.expandedTodoId)
  }

  @Test
  fun onTodoMarkerDismissed_ClearsExpandedTodoId() = runTest {
    val repo = BootcampToDosRepositoryLocal()
    val vm = MapViewModel(repo)

    vm.onTodoMarkerTapped("todo1")
    assertEquals("todo1", vm.uiState.value.expandedTodoId)

    vm.onTodoMarkerDismissed()

    assertNull(vm.uiState.value.expandedTodoId)
  }
}
