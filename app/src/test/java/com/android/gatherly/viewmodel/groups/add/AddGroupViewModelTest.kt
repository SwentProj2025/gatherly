package com.android.gatherly.viewmodel.groups.add

import com.android.gatherly.model.notification.NotificationType
import com.android.gatherly.model.notification.NotificationsLocalRepository
import com.android.gatherly.model.notification.NotificationsRepository
import com.android.gatherly.model.points.PointsLocalRepository
import com.android.gatherly.model.points.PointsRepository
import com.android.gatherly.model.profile.ProfileLocalRepository
import com.android.gatherly.ui.groups.AddGroupViewModel
import com.android.gatherly.utilstest.MockitoUtils
import com.android.gatherly.viewmodel.FakeGroupsRepositoryLocal
import com.android.gatherly.viewmodel.groups.add.AddGroupViewModelTestData.ALL_FRIENDS
import com.android.gatherly.viewmodel.groups.add.AddGroupViewModelTestData.CURRENT_USER_PROFILE
import com.android.gatherly.viewmodel.groups.add.AddGroupViewModelTestData.FRIEND_ALICE
import com.android.gatherly.viewmodel.groups.add.AddGroupViewModelTestData.FRIEND_BOB
import com.android.gatherly.viewmodel.groups.add.AddGroupViewModelTestData.FRIEND_CHARLIE
import com.android.gatherly.viewmodel.groups.add.AddGroupViewModelTestData.TEST_USER_ID
import kotlin.time.Duration.Companion.seconds
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.test.UnconfinedTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.resetMain
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.After
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test

// This file contains code generated by an LLM (Claude.ai).

/**
 * Unit tests for [AddGroupViewModel].
 *
 * Tests the group creation flow including friend list loading, field validation, friend selection,
 * group saving, and error handling. Uses fake repositories and mocked Firebase Auth to isolate
 * business logic from external dependencies.
 *
 * Test categories:
 * - Initial state verification
 * - Friend list loading (success, auth errors, profile errors)
 * - Input field updates (name, description)
 * - Friend selection/deselection (single and multiple)
 * - Group saving (valid data, validation failures, repository errors)
 * - State clearing methods
 */
@OptIn(ExperimentalCoroutinesApi::class)
class AddGroupViewModelTest {

  private lateinit var groupsRepository: FakeGroupsRepositoryLocal
  private lateinit var profileRepository: ProfileLocalRepository
  private lateinit var notificationsRepository: NotificationsRepository
  private lateinit var pointsRepository: PointsRepository
  private lateinit var mockitoUtils: MockitoUtils

  private val testDispatcher = UnconfinedTestDispatcher()
  val testTimeout = 120.seconds

  /**
   * Sets up test fixtures before each test.
   *
   * Initializes fake repositories with test data, mocks Firebase Auth to return a test user ID, and
   * populates the profile repository with the current user and their friends. Sets the Main
   * dispatcher to the test dispatcher for proper coroutine testing.
   */
  @Before
  fun setup() {
    Dispatchers.setMain(testDispatcher)

    groupsRepository = FakeGroupsRepositoryLocal(currentUserId = TEST_USER_ID)
    profileRepository = ProfileLocalRepository()
    notificationsRepository = NotificationsLocalRepository()
    pointsRepository = PointsLocalRepository()

    // Mock Firebase Auth
    mockitoUtils = MockitoUtils()
    mockitoUtils.chooseCurrentUser(TEST_USER_ID)

    // Populate profile repository with test data
    runBlocking {
      profileRepository.addProfile(CURRENT_USER_PROFILE)
      ALL_FRIENDS.forEach { friend -> profileRepository.addProfile(friend) }
    }
  }

  /** Cleans up after each test by resetting the Main dispatcher. */
  @After
  fun tearDown() {
    Dispatchers.resetMain()
  }

  private fun createViewModel(): AddGroupViewModel {
    return AddGroupViewModel(
        groupsRepository = groupsRepository,
        profileRepository = profileRepository,
        notificationsRepository = notificationsRepository,
        pointsRepository = pointsRepository,
        authProvider = { mockitoUtils.mockAuth })
  }

  /**
   * Verifies that the ViewModel initializes with correct default values.
   *
   * Checks that all fields are empty/default, friends list is loaded, and no errors or loading
   * states are active after initialization.
   */
  @Test
  fun initialState_IsCorrect() =
      runTest(testDispatcher, testTimeout) {
        val viewModel = createViewModel()
        advanceUntilIdle()

        val state = viewModel.uiState.value
        assertEquals("", state.name)
        assertEquals("", state.description)
        assertNull(state.nameError)
        assertEquals(ALL_FRIENDS, state.friendsList)
        assertTrue(state.selectedFriends.isEmpty())
        assertFalse(state.isFriendsLoading)
        assertNull(state.friendsError)
        assertFalse(state.isSaving)
        assertNull(state.saveError)
        assertFalse(state.saveSuccess)
      }

  /**
   * Verifies that the ViewModel successfully loads the current user's friends on initialization.
   *
   * Checks that all friends from the user's profile are loaded into the UI state without errors.
   */
  @Test
  fun loadFriends_LoadsCurrentUsersFriends() =
      runTest(testDispatcher, testTimeout) {
        val viewModel = createViewModel()
        advanceUntilIdle()

        val state = viewModel.uiState.value
        assertEquals(3, state.friendsList.size)
        assertTrue(state.friendsList.contains(FRIEND_ALICE))
        assertTrue(state.friendsList.contains(FRIEND_BOB))
        assertFalse(state.isFriendsLoading)
        assertNull(state.friendsError)
      }

  /**
   * Verifies that an appropriate error is set when there is no authenticated user.
   *
   * Tests the error handling path when Firebase Auth returns null for the current user.
   */
  @Test
  fun loadFriends_NoAuthenticatedUser_SetsError() =
      runTest(testDispatcher, testTimeout) {
        mockitoUtils.unauthenticatedCurrentUser()

        val viewModel = createViewModel()
        advanceUntilIdle()

        val state = viewModel.uiState.value
        assertTrue(state.friendsList.isEmpty())
        assertNotNull(state.friendsError)
        assertTrue(state.friendsError!!.contains("No signed in user"))
        assertFalse(state.isFriendsLoading)
      }

  /**
   * Verifies that an error is set when the current user's profile cannot be found.
   *
   * Tests the error handling path when the profile repository does not contain the user's profile.
   */
  @Test
  fun loadFriends_ProfileNotFound_SetsError() =
      runTest(testDispatcher, testTimeout) {
        // Remove current user's profile
        profileRepository.deleteProfile(CURRENT_USER_PROFILE.uid)

        val viewModel = createViewModel()
        advanceUntilIdle()

        val state = viewModel.uiState.value
        assertTrue(state.friendsList.isEmpty())
        assertNotNull(state.friendsError)
        assertFalse(state.isFriendsLoading)
      }

  /**
   * Verifies that a valid name updates the state and clears any validation errors.
   *
   * Tests the happy path for name input where the value is non-blank.
   */
  @Test
  fun onNameChanged_ValidName_UpdatesStateAndClearsError() =
      runTest(testDispatcher, testTimeout) {
        val viewModel = createViewModel()
        advanceUntilIdle()

        viewModel.onNameChanged("Study Group")

        val state = viewModel.uiState.value
        assertEquals("Study Group", state.name)
        assertNull(state.nameError)
      }

  /**
   * Verifies that a blank name triggers a validation error.
   *
   * Tests that an empty string name results in an appropriate error message.
   */
  @Test
  fun onNameChanged_BlankName_SetsError() =
      runTest(testDispatcher, testTimeout) {
        val viewModel = createViewModel()
        advanceUntilIdle()

        viewModel.onNameChanged("")

        val state = viewModel.uiState.value
        assertEquals("", state.name)
        assertEquals("Name cannot be empty", state.nameError)
      }

  /**
   * Verifies that a whitespace-only name triggers a validation error.
   *
   * Tests that names containing only spaces are treated as blank and trigger validation errors.
   */
  @Test
  fun onNameChanged_WhitespaceName_SetsError() =
      runTest(testDispatcher, testTimeout) {
        val viewModel = createViewModel()
        advanceUntilIdle()

        viewModel.onNameChanged("   ")

        val state = viewModel.uiState.value
        assertEquals("   ", state.name)
        assertEquals("Name cannot be empty", state.nameError)
      }

  /**
   * Verifies that description changes are correctly reflected in the UI state.
   *
   * Tests that the description field updates without validation (description is optional).
   */
  @Test
  fun onDescriptionChanged_UpdatesState() =
      runTest(testDispatcher, testTimeout) {
        val viewModel = createViewModel()
        advanceUntilIdle()

        viewModel.onDescriptionChanged("A group for studying together")

        val state = viewModel.uiState.value
        assertEquals("A group for studying together", state.description)
      }

  /**
   * Verifies that toggling an unselected friend adds them to the selected friends list.
   *
   * Tests the friend selection mechanism for adding a friend to the group.
   */
  @Test
  fun onFriendToggled_SelectsFriend() =
      runTest(testDispatcher, testTimeout) {
        val viewModel = createViewModel()
        advanceUntilIdle()

        viewModel.onFriendToggled(FRIEND_ALICE)

        val state = viewModel.uiState.value
        assertTrue(state.selectedFriends.contains(FRIEND_ALICE))
        assertEquals(1, state.selectedFriends.size)
      }

  /**
   * Verifies that toggling a selected friend removes them from the selected friends list.
   *
   * Tests the friend deselection mechanism for removing a friend from the group.
   */
  @Test
  fun onFriendToggled_DeselectsFriend() =
      runTest(testDispatcher, testTimeout) {
        val viewModel = createViewModel()
        advanceUntilIdle()

        // Select then deselect
        viewModel.onFriendToggled(FRIEND_ALICE)
        viewModel.onFriendToggled(FRIEND_ALICE)

        val state = viewModel.uiState.value
        assertFalse(state.selectedFriends.contains(FRIEND_ALICE))
        assertTrue(state.selectedFriends.isEmpty())
      }

  /**
   * Verifies that multiple friends can be selected simultaneously.
   *
   * Tests that the selection mechanism correctly maintains a list of multiple selected friends.
   */
  @Test
  fun onFriendToggled_SelectMultipleFriends() =
      runTest(testDispatcher, testTimeout) {
        val viewModel = createViewModel()
        advanceUntilIdle()

        viewModel.onFriendToggled(FRIEND_ALICE)
        viewModel.onFriendToggled(FRIEND_BOB)

        val state = viewModel.uiState.value
        assertEquals(2, state.selectedFriends.size)
        assertTrue(state.selectedFriends.contains(FRIEND_ALICE))
        assertTrue(state.selectedFriends.contains(FRIEND_BOB))
      }

  /**
   * Verifies that a group is successfully created with valid data.
   *
   * Tests the complete save flow including name, description, and selected friends. Verifies that
   * the group is persisted to the repository with correct values.
   */
  @Test
  fun saveGroup_WithValidData_CreatesGroup() =
      runTest(testDispatcher, testTimeout) {
        val viewModel = createViewModel()
        advanceUntilIdle()

        viewModel.onNameChanged("Study Group")
        viewModel.onDescriptionChanged("Weekly study sessions")
        viewModel.onFriendToggled(FRIEND_ALICE)
        viewModel.onFriendToggled(FRIEND_BOB)

        viewModel.saveGroup()
        advanceUntilIdle()

        val state = viewModel.uiState.value
        assertTrue(state.saveSuccess)
        assertFalse(state.isSaving)
        assertNull(state.saveError)

        // Verify group was created in repository
        val groups = groupsRepository.getAllGroups()
        assertEquals(1, groups.size)
        val savedGroup = groups[0]
        assertEquals("Study Group", savedGroup.name)
        assertEquals("Weekly study sessions", savedGroup.description)
        assertTrue(savedGroup.memberIds.contains(FRIEND_ALICE.uid))
        assertTrue(savedGroup.memberIds.contains(FRIEND_BOB.uid))
      }

  /**
   * Verifies that a group with a blank description saves with null description.
   *
   * Tests that empty/blank descriptions are converted to null in the saved group.
   */
  @Test
  fun saveGroup_WithBlankDescription_SavesWithNullDescription() =
      runTest(testDispatcher, testTimeout) {
        val viewModel = createViewModel()
        advanceUntilIdle()

        viewModel.onNameChanged("Study Group")
        // Leave description blank

        viewModel.saveGroup()
        advanceUntilIdle()

        assertTrue(viewModel.uiState.value.saveSuccess)

        val groups = groupsRepository.getAllGroups()
        assertEquals(1, groups.size)
        assertNull(groups[0].description)
      }

  /**
   * Verifies that a group can be created without any selected friends.
   *
   * Tests that groups with empty member lists can be successfully created.
   */
  @Test
  fun saveGroup_WithNoSelectedFriends_CreatesGroupWithNoMembers() =
      runTest(testDispatcher, testTimeout) {
        val viewModel = createViewModel()
        advanceUntilIdle()

        viewModel.onNameChanged("Solo Group")

        viewModel.saveGroup()
        advanceUntilIdle()

        assertTrue(viewModel.uiState.value.saveSuccess)

        val groups = groupsRepository.getAllGroups()
        assertEquals(1, groups.size)
        assertTrue(groups[0].memberIds.isEmpty())
      }

  /**
   * Verifies that save is prevented when the group name is blank.
   *
   * Tests that validation errors prevent group creation and no group is saved to the repository.
   */
  @Test
  fun saveGroup_WithBlankName_DoesNotSave() =
      runTest(testDispatcher, testTimeout) {
        val viewModel = createViewModel()
        advanceUntilIdle()

        viewModel.onNameChanged("")
        viewModel.onDescriptionChanged("Some description")

        viewModel.saveGroup()
        advanceUntilIdle()

        val state = viewModel.uiState.value
        assertFalse(state.saveSuccess)
        assertEquals("Name cannot be empty", state.nameError)
        assertFalse(state.isSaving)

        // Verify no group was created
        val groups = groupsRepository.getAllGroups()
        assertTrue(groups.isEmpty())
      }

  /**
   * Verifies that save is prevented when the group name contains only whitespace.
   *
   * Tests that whitespace-only names are treated as blank and validation prevents saving.
   */
  @Test
  fun saveGroup_WithWhitespaceName_DoesNotSave() =
      runTest(testDispatcher, testTimeout) {
        val viewModel = createViewModel()
        advanceUntilIdle()

        viewModel.onNameChanged("   ")

        viewModel.saveGroup()
        advanceUntilIdle()

        val state = viewModel.uiState.value
        assertFalse(state.saveSuccess)
        assertEquals("Name cannot be empty", state.nameError)

        val groups = groupsRepository.getAllGroups()
        assertTrue(groups.isEmpty())
      }

  /**
   * Verifies that the saving state flag is correctly managed during the save operation.
   *
   * Tests that isSaving is false before and after the save completes.
   */
  @Test
  fun saveGroup_SetsSavingStateCorrectly() =
      runTest(testDispatcher, testTimeout) {
        val viewModel = createViewModel()
        advanceUntilIdle()

        viewModel.onNameChanged("Study Group")

        // Before save
        assertFalse(viewModel.uiState.value.isSaving)

        viewModel.saveGroup()

        // During save (before advanceUntilIdle)
        // Note: isSaving will be true briefly, but we can't easily capture it in a unit test
        // without adding delays or more complex coroutine control

        advanceUntilIdle()

        // After save
        assertFalse(viewModel.uiState.value.isSaving)
      }

  /**
   * Verifies that clearErrorMsg() removes the save error from the UI state.
   *
   * Tests the error clearing mechanism after a save failure.
   */
  @Test
  fun clearErrorMsg_ClearsSaveError() =
      runTest(testDispatcher, testTimeout) {
        val viewModel = createViewModel()
        advanceUntilIdle()

        // Simulate an error (we'll use reflection or create a scenario that causes an error)
        // For this test, we'll trigger a save error by making the repository throw
        groupsRepository.shouldThrowOnAddGroup = true

        viewModel.onNameChanged("Test Group")
        viewModel.saveGroup()
        advanceUntilIdle()

        // Verify error is set
        assertNotNull(viewModel.uiState.value.saveError)

        viewModel.clearErrorMsg()

        assertNull(viewModel.uiState.value.saveError)
      }

  /**
   * Verifies that clearSaveSuccess() removes the save success flag from the UI state.
   *
   * Tests the success flag clearing mechanism after a successful save.
   */
  @Test
  fun clearSaveSuccess_ClearsSaveSuccessFlag() =
      runTest(testDispatcher, testTimeout) {
        val viewModel = createViewModel()
        advanceUntilIdle()

        viewModel.onNameChanged("Study Group")
        viewModel.saveGroup()
        advanceUntilIdle()

        assertTrue(viewModel.uiState.value.saveSuccess)

        viewModel.clearSaveSuccess()

        assertFalse(viewModel.uiState.value.saveSuccess)
      }

  /**
   * Verifies that repository exceptions during save are properly handled.
   *
   * Tests that when the repository throws an exception, the error is captured in the UI state and
   * no group is created.
   */
  @Test
  fun saveGroup_RepositoryThrowsException_SetsSaveError() =
      runTest(testDispatcher, testTimeout) {
        val viewModel = createViewModel()
        advanceUntilIdle()

        groupsRepository.shouldThrowOnAddGroup = true

        viewModel.onNameChanged("Test Group")
        viewModel.saveGroup()
        advanceUntilIdle()

        val state = viewModel.uiState.value
        assertFalse(state.saveSuccess)
        assertNotNull(state.saveError)
        assertFalse(state.isSaving)

        val groups = groupsRepository.getAllGroups()
        assertTrue(groups.isEmpty())
      }

  /**
   * Verifies that friend loading continues successfully even if some friends cannot be fetched.
   *
   * Tests the resilience of the friend loading mechanism - it should load all available friends
   * without failing when individual friend profiles are missing.
   */
  @Test
  fun loadFriends_SkipsFriendsThatCannotBeFetched() =
      runTest(testDispatcher, testTimeout) {
        // Remove one friend from the repository
        profileRepository.deleteProfile(FRIEND_BOB.uid)

        val viewModel = createViewModel()
        advanceUntilIdle()

        val state = viewModel.uiState.value
        // Should load successfully with only 2 friends
        assertEquals(2, state.friendsList.size)
        assertTrue(state.friendsList.contains(FRIEND_ALICE))
        assertFalse(state.friendsList.contains(FRIEND_BOB))
        assertFalse(state.isFriendsLoading)
        assertNull(state.friendsError) // No error because the operation succeeds partially
      }

  /**
   * Verifies that upon group creation, members that were added get a notification, and members that
   * weren't don't
   */
  @Test
  fun saveGroupSendsNotificationToMembers() =
      runTest(testDispatcher, testTimeout) {
        val viewModel = createViewModel()
        advanceUntilIdle()

        // Add Alice
        viewModel.onFriendToggled(FRIEND_ALICE)
        advanceUntilIdle()

        // Input a name
        viewModel.onNameChanged("Alice & Me :)")
        advanceUntilIdle()

        // Save the group
        viewModel.saveGroup()
        advanceUntilIdle()

        // Check that notifications are sent
        val aliceNotifs = notificationsRepository.getUserNotifications(FRIEND_ALICE.uid)
        val bobNotifs = notificationsRepository.getUserNotifications(FRIEND_BOB.uid)

        // Check that Alice has a notification of the correct type, and Bob has no notifications

        assertEquals(1, aliceNotifs.size)
        assertEquals(NotificationType.GROUP_ADDED, aliceNotifs[0].type)

        assertEquals(0, bobNotifs.size)
      }

  /** Checks that searching and then clearing the search query has the intended behaviour */
  @Test
  fun filterFriendsCorrectlyFilters() =
      runTest(testDispatcher, testTimeout) {
        val viewModel = createViewModel()

        viewModel.filterFriends("a")
        advanceUntilIdle()

        assertEquals(listOf(FRIEND_ALICE, FRIEND_CHARLIE), viewModel.uiState.value.friendsList)

        viewModel.filterFriends("")
        advanceUntilIdle()

        assertEquals(ALL_FRIENDS, viewModel.uiState.value.friendsList)
      }
}
