package com.android.gatherly.viewmodel.todo

import androidx.test.ext.junit.runners.AndroidJUnit4
import com.android.gatherly.model.todo.ToDo
import com.android.gatherly.model.todo.ToDoStatus
import com.android.gatherly.model.todo.ToDosRepository
import com.android.gatherly.ui.todo.EditTodoViewModel
import com.android.gatherly.utils.FirestoreGatherlyTest
import com.google.firebase.Timestamp
import com.google.firebase.auth.ktx.auth
import com.google.firebase.ktx.Firebase
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.withContext
import kotlinx.coroutines.withTimeout
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith

private const val TIMEOUT = 100_000L
private const val DELAY = 100L

// Portions of the code in this file were generated by an LLM.

/**
 * Integration tests for [com.android.gatherly.ui.todo.EditTodoViewModel] using the real Firestore
 * repository (via emulator).
 *
 * These tests verify that valid edits update Firestore correctly, invalid inputs are rejected, and
 * repository errors are surfaced in UI state.
 */
@RunWith(AndroidJUnit4::class)
class EditTodoViewModelFirestoreTest : FirestoreGatherlyTest() {

  private lateinit var viewModel: EditTodoViewModel
  private lateinit var baseTodo: ToDo

  @Before
  override fun setUp() {
    super.setUp()
    viewModel = EditTodoViewModel(repository)

    // Create a base ToDo in Firestore to edit later
    runTest {
      baseTodo =
          ToDo(
              uid = repository.getNewUid(),
              name = "Initial task",
              description = "Original description",
              assigneeName = "John",
              dueDate = Timestamp.now(),
              dueTime = null,
              location = null,
              status = ToDoStatus.ONGOING,
              ownerId = "owner")
      repository.addTodo(baseTodo)
    }
  }

  @Test
  fun loadTodo_withValidId_loadsSuccessfully() = runTest {
    viewModel.loadTodo(baseTodo.uid)

    withContext(Dispatchers.Default.limitedParallelism(1)) {
      withTimeout(TIMEOUT) {
        while (viewModel.uiState.value.title.isEmpty() &&
            viewModel.uiState.value.errorMsg == null) {
          delay(DELAY)
        }
      }
    }

    val state = viewModel.uiState.value
    assertEquals("Initial task", state.title)
    assertEquals("Original description", state.description)
    assertEquals("John", state.assignee)
    assertNull(state.errorMsg)
  }

  @Test
  fun loadTodo_withInvalidId_setsErrorMessage() = runTest {
    viewModel.loadTodo("nonexistent-id")

    withContext(Dispatchers.Default.limitedParallelism(1)) {
      withTimeout(TIMEOUT) {
        while (viewModel.uiState.value.errorMsg == null) {
          delay(DELAY)
        }
      }
    }

    assertTrue(viewModel.uiState.value.errorMsg!!.contains("Failed to load ToDo"))
  }

  @Test
  fun editTodo_withValidFields_updatesRepository() = runTest {
    // Load the current ToDo
    viewModel.loadTodo(baseTodo.uid)
    withContext(Dispatchers.Default.limitedParallelism(1)) {
      withTimeout(TIMEOUT) { while (viewModel.uiState.value.title.isBlank()) delay(DELAY) }
    }

    // Provide valid values for all required fields
    viewModel.onTitleChanged("Updated title")
    viewModel.onDescriptionChanged("Updated description")
    viewModel.onAssigneeChanged("Mary")
    viewModel.onDateChanged("10/10/2025")
    viewModel.onTimeChanged("14:00")
    viewModel.onLocationChanged("Place")

    // Perform the edit
    viewModel.editTodo(baseTodo.uid)

    // Wait for async Firestore write
    withContext(Dispatchers.Default.limitedParallelism(1)) {
      withTimeout(TIMEOUT) {
        var updated: ToDo? = null
        while (updated == null || updated.name != "Updated title") {
          delay(DELAY)
          updated = repository.getTodo(baseTodo.uid)
        }
      }
    }

    val updated = repository.getTodo(baseTodo.uid)
    assertEquals("Updated title", updated.name)
    assertEquals("Updated description", updated.description)
    assertEquals("Mary", updated.assigneeName)
    assertEquals(ToDoStatus.ONGOING, updated.status)
    assertEquals(baseTodo.uid, updated.uid)

    val expectedOwnerId = Firebase.auth.currentUser?.uid ?: "owner"
    assertEquals(expectedOwnerId, updated.ownerId)
  }

  @Test
  fun editTodo_withInvalidDate_doesNotSave() = runTest {
    viewModel.onTitleChanged("Invalid edit")
    viewModel.onDescriptionChanged("Bad date")
    viewModel.onAssigneeChanged("User")
    viewModel.onDateChanged("15-10-2025") // Wrong format
    viewModel.onTimeChanged("14:00")
    viewModel.onLocationChanged("Place")

    viewModel.editTodo(baseTodo.uid)
    delay(DELAY)

    val state = viewModel.uiState.value
    assertNotNull(state.dueDateError)
    assertTrue(state.dueDateError!!.contains("Invalid format (dd/MM/yyyy)"))
  }

  @Test
  fun editTodo_withEmptyFields_doesNotProceed() = runTest {
    viewModel.onTitleChanged("") // Missing title
    viewModel.onDescriptionChanged("Desc")
    viewModel.onAssigneeChanged("A")
    viewModel.onDateChanged("10/10/2025")
    viewModel.onTimeChanged("14:00")
    viewModel.onLocationChanged("Place")

    viewModel.editTodo(baseTodo.uid)
    delay(DELAY)

    val state = viewModel.uiState.value
    assertEquals("Title cannot be empty", state.titleError)
  }

  @Test
  fun deleteTodo_removesItemFromRepository() = runTest {
    repository.addTodo(
        ToDo(
            uid = "delete-me",
            name = "To delete",
            description = "temporary",
            assigneeName = "Someone",
            dueDate = Timestamp.now(),
            dueTime = null,
            location = null,
            status = ToDoStatus.ONGOING,
            ownerId = "owner"))

    viewModel.deleteToDo("delete-me")
    // Wait deterministically until the repository no longer contains it
    withContext(Dispatchers.Default.limitedParallelism(1)) {
      withTimeout(TIMEOUT) {
        while (repository.getAllTodos().any { it.uid == "delete-me" }) {
          delay(DELAY)
        }
      }
    }

    val all = repository.getAllTodos()
    assertTrue(all.none { it.uid == "delete-me" })
  }

  @Test
  fun deleteTodo_withFailure_setsErrorMsg() = runTest {
    val failingRepo =
        object : ToDosRepository {
          override suspend fun addTodo(toDo: ToDo) = Unit

          override suspend fun getAllTodos() = emptyList<ToDo>()

          override suspend fun getTodo(todoID: String) = baseTodo

          override suspend fun deleteTodo(todoID: String) {
            throw RuntimeException("Simulated delete failure")
          }

          override suspend fun editTodo(todoID: String, newValue: ToDo) = Unit

          override suspend fun getAllEndedTodos() = emptyList<ToDo>()

          override fun getNewUid() = "fake"

          override suspend fun toggleStatus(todoID: String) = Unit
        }

    val viewModel = EditTodoViewModel(failingRepo)
    viewModel.deleteToDo("anything")

    withContext(Dispatchers.Default.limitedParallelism(1)) {
      withTimeout(TIMEOUT) {
        while (viewModel.uiState.value.errorMsg == null) {
          delay(DELAY)
        }
      }
    }

    assertTrue(viewModel.uiState.value.errorMsg!!.contains("Failed to delete ToDo"))
  }
}
