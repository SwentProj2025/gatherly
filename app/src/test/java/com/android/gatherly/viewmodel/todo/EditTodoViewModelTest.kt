package com.android.gatherly.viewmodel.todo

import androidx.test.ext.junit.runners.AndroidJUnit4
import com.android.gatherly.model.profile.ProfileLocalRepository
import com.android.gatherly.model.profile.ProfileRepository
import com.android.gatherly.model.todo.ToDo
import com.android.gatherly.model.todo.ToDoStatus
import com.android.gatherly.model.todo.ToDosLocalRepository
import com.android.gatherly.model.todo.ToDosRepository
import com.android.gatherly.model.todoCategory.ToDoCategoryLocalRepository
import com.android.gatherly.model.todoCategory.ToDoCategoryRepository
import com.android.gatherly.ui.todo.EditTodoViewModel
import com.android.gatherly.utilstest.MockitoUtils
import com.google.firebase.Timestamp
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.resetMain
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.After
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith

// Portions of the code in this file were generated by an LLM.

/**
 * Integration tests for [com.android.gatherly.ui.todo.EditTodoViewModel] using the real Firestore
 * repository (via emulator).
 *
 * These tests verify that valid edits update Firestore correctly, invalid inputs are rejected, and
 * repository errors are surfaced in UI state.
 */
@RunWith(AndroidJUnit4::class)
@OptIn(ExperimentalCoroutinesApi::class)
class EditTodoViewModelTest {

  private lateinit var editTodoViewModel: EditTodoViewModel
  private lateinit var toDosRepository: ToDosRepository
  private lateinit var profileRepository: ProfileRepository
  private lateinit var toDoCategoryRepository: ToDoCategoryRepository
  private lateinit var baseTodo: ToDo
  private lateinit var mockitoUtils: MockitoUtils

  // initialize this so that tests control all coroutines and can wait on them
  private val testDispatcher = StandardTestDispatcher()

  @Before
  fun setUp() {
    // so that tests can wait on coroutines
    Dispatchers.setMain(testDispatcher)

    toDosRepository = ToDosLocalRepository()
    profileRepository = ProfileLocalRepository()
    toDoCategoryRepository = ToDoCategoryLocalRepository()
    fillRepository()

    // Mock Firebase Auth
    mockitoUtils = MockitoUtils()
    mockitoUtils.chooseCurrentUser("owner")

    editTodoViewModel =
        EditTodoViewModel(
            todoRepository = toDosRepository,
            profileRepository = profileRepository,
            todoCategoryRepository = toDoCategoryRepository)
  }

  @After
  fun tearDown() {
    Dispatchers.resetMain()
  }

  private fun fillRepository() = runTest {
    baseTodo =
        ToDo(
            uid = toDosRepository.getNewUid(),
            name = "Initial task",
            description = "Original description",
            dueDate = Timestamp.now(),
            dueTime = null,
            location = null,
            status = ToDoStatus.ONGOING,
            ownerId = "owner")
    toDosRepository.addTodo(baseTodo)
    advanceUntilIdle()
  }

  @Test
  fun loadTodo_withValidId_loadsSuccessfully() = runTest {
    editTodoViewModel.loadTodo(baseTodo.uid)

    advanceUntilIdle()

    val state = editTodoViewModel.uiState.value
    assertNull(state.errorMsg)
    assertEquals("Initial task", state.title)
    assertEquals("Original description", state.description)
    assertNull(state.errorMsg)
  }

  @Test
  fun loadTodo_withInvalidId_setsErrorMessage() = runTest {
    editTodoViewModel.loadTodo("nonexistent-id")

    advanceUntilIdle()

    assertTrue(editTodoViewModel.uiState.value.errorMsg!!.contains("Failed to load ToDo"))
  }

  @Test
  fun editTodo_withValidFields_updatesRepository() = runTest {
    // Load the current ToDo
    editTodoViewModel.loadTodo(baseTodo.uid)
    advanceUntilIdle()

    // Provide valid values for all required fields
    editTodoViewModel.onTitleChanged("Updated title")
    editTodoViewModel.onDescriptionChanged("Updated description")
    editTodoViewModel.onDateChanged("10/10/2025")
    editTodoViewModel.onTimeChanged("14:00")
    editTodoViewModel.onLocationChanged("Place")

    // Perform the edit
    editTodoViewModel.editTodo(baseTodo.uid)

    // Wait for async Firestore write
    advanceUntilIdle()

    val updated = toDosRepository.getTodo(baseTodo.uid)
    assertEquals("Updated title", updated.name)
    assertEquals("Updated description", updated.description)
    assertEquals(ToDoStatus.ONGOING, updated.status)
    assertEquals(baseTodo.uid, updated.uid)

    val expectedOwnerId = "owner"
    assertEquals(expectedOwnerId, updated.ownerId)
  }

  @Test
  fun editTodo_withInvalidDate_doesNotSave() = runTest {
    editTodoViewModel.onTitleChanged("Invalid edit")
    editTodoViewModel.onDescriptionChanged("Bad date")
    editTodoViewModel.onDateChanged("15-10-2025") // Wrong format
    editTodoViewModel.onTimeChanged("14:00")
    editTodoViewModel.onLocationChanged("Place")

    editTodoViewModel.checkPastTime()
    advanceUntilIdle()

    val state = editTodoViewModel.uiState.value
    assertNotNull(state.dueDateError)
    assertTrue(state.dueDateError!!.contains("Invalid format (dd/MM/yyyy)"))
  }

  @Test
  fun editTodo_withEmptyFields_doesNotProceed() = runTest {
    editTodoViewModel.onTitleChanged("") // Missing title
    editTodoViewModel.onDescriptionChanged("Desc")
    editTodoViewModel.onDateChanged("10/10/2025")
    editTodoViewModel.onTimeChanged("14:00")
    editTodoViewModel.onLocationChanged("Place")

    editTodoViewModel.editTodo(baseTodo.uid)
    advanceUntilIdle()

    val state = editTodoViewModel.uiState.value
    assertEquals("Title cannot be empty", state.titleError)
  }

  @Test
  fun deleteTodo_removesItemFromRepository() = runTest {
    toDosRepository.addTodo(
        ToDo(
            uid = "delete-me",
            name = "To delete",
            description = "temporary",
            dueDate = Timestamp.now(),
            dueTime = null,
            location = null,
            status = ToDoStatus.ONGOING,
            ownerId = "owner"))

    editTodoViewModel.deleteToDo("delete-me")
    // Wait deterministically until the repository no longer contains it
    advanceUntilIdle()

    val all = toDosRepository.getAllTodos()
    assertTrue(all.none { it.uid == "delete-me" })
  }

  @Test
  fun deleteTodo_withFailure_setsErrorMsg() = runTest {
    val failingRepo =
        object : ToDosRepository {
          override suspend fun addTodo(toDo: ToDo) = Unit

          override suspend fun getAllTodos() = emptyList<ToDo>()

          override suspend fun getTodo(todoID: String) = baseTodo

          override suspend fun deleteTodo(todoID: String) {
            throw RuntimeException("Simulated delete failure")
          }

          override suspend fun editTodo(todoID: String, newValue: ToDo) = Unit

          override suspend fun getAllEndedTodos() = emptyList<ToDo>()

          override fun getNewUid() = "fake"

          override suspend fun toggleStatus(todoID: String) = Unit
        }

    val viewModel =
        EditTodoViewModel(
            failingRepo,
            profileRepository = profileRepository,
            todoCategoryRepository = toDoCategoryRepository)
    viewModel.deleteToDo("anything")

    advanceUntilIdle()

    assertTrue(viewModel.uiState.value.errorMsg!!.contains("Failed to delete ToDo"))
  }
}
