package com.android.gatherly.viewmodel.todo

import androidx.test.ext.junit.runners.AndroidJUnit4
import com.android.gatherly.model.profile.ProfileLocalRepository
import com.android.gatherly.model.profile.ProfileRepository
import com.android.gatherly.model.todo.ToDo
import com.android.gatherly.model.todo.ToDoStatus
import com.android.gatherly.model.todo.ToDosLocalRepository
import com.android.gatherly.model.todo.ToDosRepository
import com.android.gatherly.model.todoCategory.ToDoCategoryLocalRepository
import com.android.gatherly.model.todoCategory.ToDoCategoryRepository
import com.android.gatherly.ui.todo.EditTodoViewModel
import com.android.gatherly.utilstest.MockitoUtils
import com.google.firebase.Timestamp
import kotlin.time.Duration.Companion.seconds
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.UnconfinedTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.resetMain
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.After
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith

// Portions of the code in this file were generated by an LLM.

/**
 * Integration tests for [com.android.gatherly.ui.todo.EditTodoViewModel] using the real Firestore
 * repository (via emulator).
 *
 * These tests verify that valid edits update Firestore correctly, invalid inputs are rejected, and
 * repository errors are surfaced in UI state.
 */
@RunWith(AndroidJUnit4::class)
@OptIn(ExperimentalCoroutinesApi::class)
class EditTodoViewModelTest {

  private lateinit var editTodoViewModel: EditTodoViewModel
  private lateinit var toDosRepository: ToDosRepository
  private lateinit var profileRepository: ProfileRepository
  private lateinit var toDoCategoryRepository: ToDoCategoryRepository
  private lateinit var baseTodo: ToDo
  private lateinit var mockitoUtils: MockitoUtils

  // initialize this so that tests control all coroutines and can wait on them
  private val testDispatcher = UnconfinedTestDispatcher()
  private val testTimeout = 120.seconds

  @Before
  fun setUp() {
    // so that tests can wait on coroutines
    Dispatchers.setMain(testDispatcher)

    toDosRepository = ToDosLocalRepository()
    profileRepository = ProfileLocalRepository()
    toDoCategoryRepository = ToDoCategoryLocalRepository()
    fillRepository()

    // Mock Firebase Auth
    mockitoUtils = MockitoUtils()
    mockitoUtils.chooseCurrentUser("owner")

    editTodoViewModel =
        EditTodoViewModel(
            todoRepository = toDosRepository, todoCategoryRepository = toDoCategoryRepository)
  }

  @After
  fun tearDown() {
    Dispatchers.resetMain()
  }

  private fun fillRepository() =
      runTest(testDispatcher, testTimeout) {
        baseTodo =
            ToDo(
                uid = toDosRepository.getNewUid(),
                name = "Initial task",
                description = "Original description",
                dueDate = Timestamp.now(),
                dueTime = null,
                location = null,
                status = ToDoStatus.ONGOING,
                ownerId = "owner")
        toDosRepository.addTodo(baseTodo)
        advanceUntilIdle()
      }

  /** Test loading a `ToDo` with a valid ID. */
  @Test
  fun loadTodo_withValidId_loadsSuccessfully() =
      runTest(testDispatcher, testTimeout) {
        editTodoViewModel.loadTodo(baseTodo.uid)

        advanceUntilIdle()

        val state = editTodoViewModel.uiState.value
        assertNull(state.errorMsg)
        assertEquals("Initial task", state.title)
        assertEquals("Original description", state.description)
        assertNull(state.errorMsg)
      }

  /** Test loading a `ToDo` with an invalid ID. */
  @Test
  fun loadTodo_withInvalidId_setsErrorMessage() =
      runTest(testDispatcher, testTimeout) {
        editTodoViewModel.loadTodo("nonexistent-id")

        advanceUntilIdle()

        assertTrue(editTodoViewModel.uiState.value.errorMsg!!.contains("Failed to load ToDo"))
      }

  /** Test editing a `ToDo` with valid fields. */
  @Test
  fun editTodo_withValidFields_updatesRepository() =
      runTest(testDispatcher, testTimeout) {
        // Load the current ToDo
        editTodoViewModel.loadTodo(baseTodo.uid)
        advanceUntilIdle()

        // Provide valid values for all required fields
        editTodoViewModel.onTitleChanged("Updated title")
        editTodoViewModel.onDescriptionChanged("Updated description")
        editTodoViewModel.onDateChanged("10/10/2025")
        editTodoViewModel.onTimeChanged("14:00")
        editTodoViewModel.onLocationChanged("Place")

        // Perform the edit
        editTodoViewModel.editTodo(baseTodo.uid)

        // Wait for async Firestore write
        advanceUntilIdle()

        val updated = toDosRepository.getTodo(baseTodo.uid)
        assertEquals("Updated title", updated.name)
        assertEquals("Updated description", updated.description)
        assertEquals(ToDoStatus.ONGOING, updated.status)
        assertEquals(baseTodo.uid, updated.uid)

        val expectedOwnerId = "owner"
        assertEquals(expectedOwnerId, updated.ownerId)
      }

  /** Test editing a `ToDo` with an invalid date format. */
  @Test
  fun editTodo_withInvalidDate_doesNotSave() =
      runTest(testDispatcher, testTimeout) {
        editTodoViewModel.onTitleChanged("Invalid edit")
        editTodoViewModel.onDescriptionChanged("Bad date")
        editTodoViewModel.onDateChanged("15-10-2025") // Wrong format
        editTodoViewModel.onTimeChanged("14:00")
        editTodoViewModel.onLocationChanged("Place")

        editTodoViewModel.checkPastTime()
        advanceUntilIdle()

        val state = editTodoViewModel.uiState.value
        assertNotNull(state.dueDateError)
        assertTrue(state.dueDateError!!.contains("Invalid format (dd/MM/yyyy)"))
      }

  /** Test editing a `ToDo` with missing required fields. */
  @Test
  fun editTodo_withEmptyFields_doesNotProceed() =
      runTest(testDispatcher, testTimeout) {
        editTodoViewModel.onTitleChanged("") // Missing title
        editTodoViewModel.onDescriptionChanged("Desc")
        editTodoViewModel.onDateChanged("10/10/2025")
        editTodoViewModel.onTimeChanged("14:00")
        editTodoViewModel.onLocationChanged("Place")

        editTodoViewModel.editTodo(baseTodo.uid)
        advanceUntilIdle()

        val state = editTodoViewModel.uiState.value
        assertFalse(state.saveSuccess) // <-- Add this
        assertEquals("Title cannot be empty", state.titleError)
      }

  /** Test deleting a `ToDo`. */
  @Test
  fun deleteTodo_removesItemFromRepository() =
      runTest(testDispatcher, testTimeout) {
        toDosRepository.addTodo(
            ToDo(
                uid = "delete-me",
                name = "To delete",
                description = "temporary",
                dueDate = Timestamp.now(),
                dueTime = null,
                location = null,
                status = ToDoStatus.ONGOING,
                ownerId = "owner"))

        editTodoViewModel.deleteToDo("delete-me")
        // Wait deterministically until the repository no longer contains it
        advanceUntilIdle()

        val all = toDosRepository.getAllTodos()
        assertTrue(all.none { it.uid == "delete-me" })
      }

  /** Test deleting a `ToDo` that triggers a repository error. */
  @Test
  fun deleteTodo_withFailure_setsErrorMsg() =
      runTest(testDispatcher, testTimeout) {
        val failingRepo =
            object : ToDosRepository by toDosRepository {
              override suspend fun deleteTodo(todoID: String) {
                throw RuntimeException("Simulated delete failure")
              }

              override suspend fun getAllTodos() = emptyList<ToDo>()

              override suspend fun getTodo(todoID: String) = baseTodo

              override fun getNewUid() = "fake"
            }

        /**
         * val failingRepo2 = object : ToDosRepository { override suspend fun addTodo(toDo: ToDo) =
         * Unit
         *
         * override suspend fun getAllTodos() = emptyList<ToDo>()
         *
         * override suspend fun getTodo(todoID: String) = baseTodo
         *
         * override suspend fun deleteTodo(todoID: String) { throw RuntimeException("Simulated
         * delete failure") }
         *
         * override suspend fun editTodo(todoID: String, newValue: ToDo) = Unit
         *
         * override suspend fun getAllEndedTodos() = emptyList<ToDo>()
         *
         * override suspend fun updateTodosTagToNull(categoryId: String, ownerId: String) {}
         *
         * override fun getNewUid() = "fake"
         *
         * override suspend fun toggleStatus(todoID: String) = Unit }
         */
        val viewModel =
            EditTodoViewModel(failingRepo, todoCategoryRepository = toDoCategoryRepository)
        viewModel.deleteToDo("anything")

        advanceUntilIdle()

        assertTrue(viewModel.uiState.value.errorMsg!!.contains("Failed to delete ToDo"))
      }
}
