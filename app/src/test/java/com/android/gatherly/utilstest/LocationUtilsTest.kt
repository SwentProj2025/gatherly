package com.android.gatherly.utilstest

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.location.Location
import android.os.Looper
import androidx.core.content.ContextCompat
import com.android.gatherly.runUnconfinedTest
import com.android.gatherly.utils.createLocationRequest
import com.android.gatherly.utils.locationFlow
import com.google.android.gms.location.FusedLocationProviderClient
import com.google.android.gms.location.LocationCallback
import com.google.android.gms.location.LocationResult
import com.google.android.gms.location.Priority
import com.google.android.gms.tasks.Task
import io.mockk.*
import kotlin.time.Duration.Companion.seconds
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.launch
import kotlinx.coroutines.test.advanceUntilIdle
import org.junit.After
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test

// This file contains code generated by an LLM (Claude.ai, Gemini).

/** Unit tests for LocationUtils functions. */
class LocationUtilsTest {

  private val testTimeout = 120.seconds

  @Before
  fun setup() {
    // Mock static classes used in LocationUtils
    mockkStatic(ContextCompat::class)
    mockkStatic(Looper::class)

    // Prevent Stub error for Looper
    every { Looper.getMainLooper() } returns mockk(relaxed = true)
  }

  @After
  fun tearDown() {
    unmockkAll()
  }

  /** Test that createLocationRequest returns a LocationRequest with the expected configuration. */
  @Test
  fun createLocationRequest_hasCorrectConfiguration() {
    try {
      val request = createLocationRequest()
      assertEquals(10000L, request.intervalMillis)
      assertEquals(Priority.PRIORITY_HIGH_ACCURACY, request.priority)
    } catch (e: Exception) {
      fail("createLocationRequest threw an exception: ${e.message}")
    }
  }

  /** Test that locationFlow throws SecurityException when location permission is not granted. */
  @OptIn(ExperimentalCoroutinesApi::class)
  @Test
  fun locationFlow_withoutPermission_throwsSecurityException() =
      runUnconfinedTest(testTimeout) {
        val mockContext = mockk<Context>()
        val mockClient = mockk<FusedLocationProviderClient>()

        // Mock both permissions as DENIED
        every {
          ContextCompat.checkSelfPermission(mockContext, Manifest.permission.ACCESS_FINE_LOCATION)
        } returns PackageManager.PERMISSION_DENIED

        every {
          ContextCompat.checkSelfPermission(mockContext, Manifest.permission.ACCESS_COARSE_LOCATION)
        } returns PackageManager.PERMISSION_DENIED

        val flow = mockClient.locationFlow(mockContext)

        try {
          flow.first()
          fail("Expected SecurityException")
        } catch (e: SecurityException) {
          assertEquals("Location permission not granted", e.message)
        }
      }

  /** Test that locationFlow emits Location when location permission is granted. */
  @OptIn(ExperimentalCoroutinesApi::class)
  @Test
  fun locationFlow_withPermission_emitsLocation() =
      runUnconfinedTest(testTimeout) {
        val mockContext = mockk<Context>()
        val mockClient = mockk<FusedLocationProviderClient>(relaxed = true)
        val mockTask = mockk<Task<Void>>(relaxed = true)
        val mockLocation = mockk<Location>()

        // Mock permissions (at least one must be granted)
        every {
          ContextCompat.checkSelfPermission(mockContext, Manifest.permission.ACCESS_FINE_LOCATION)
        } returns PackageManager.PERMISSION_GRANTED

        every {
          ContextCompat.checkSelfPermission(mockContext, Manifest.permission.ACCESS_COARSE_LOCATION)
        } returns PackageManager.PERMISSION_GRANTED

        every { mockLocation.latitude } returns 46.5197
        every { mockLocation.longitude } returns 6.5663

        var capturedCallback: LocationCallback? = null

        // Allow any Looper (since the code uses Looper.getMainLooper())
        every {
          mockClient.requestLocationUpdates(any(), any<LocationCallback>(), any<Looper>())
        } answers
            {
              capturedCallback = secondArg()
              mockTask
            }

        every { mockClient.removeLocationUpdates(any<LocationCallback>()) } returns mockTask

        val flow = mockClient.locationFlow(mockContext)

        var location: Location? = null
        val job = launch { location = flow.first() }

        assertNotNull("Callback should have been captured", capturedCallback)

        val locationResult = mockk<LocationResult>(relaxed = true)
        every { locationResult.locations } returns listOf(mockLocation)

        capturedCallback?.onLocationResult(locationResult)

        assertNotNull(location)
        assertEquals(46.5197, location!!.latitude, 0.0001)
        assertEquals(6.5663, location!!.longitude, 0.0001)

        job.cancel() // cleanup
      }

  /** Test that locationFlow removes location updates when the flow collection is cancelled. */
  @OptIn(ExperimentalCoroutinesApi::class)
  @Test
  fun locationFlow_onCancellation_removesLocationUpdates() =
      runUnconfinedTest(testTimeout) {
        val mockContext = mockk<Context>()
        val mockClient = mockk<FusedLocationProviderClient>(relaxed = true)
        val mockTask = mockk<Task<Void>>(relaxed = true)

        // Mock permissions
        every {
          ContextCompat.checkSelfPermission(mockContext, Manifest.permission.ACCESS_FINE_LOCATION)
        } returns PackageManager.PERMISSION_GRANTED

        every {
          ContextCompat.checkSelfPermission(mockContext, Manifest.permission.ACCESS_COARSE_LOCATION)
        } returns PackageManager.PERMISSION_GRANTED

        var capturedCallback: LocationCallback? = null

        // Allow any Looper
        every {
          mockClient.requestLocationUpdates(any(), any<LocationCallback>(), any<Looper>())
        } answers
            {
              capturedCallback = secondArg()
              mockTask
            }

        val flow = mockClient.locationFlow(mockContext)

        val job = launch { flow.collect {} }

        advanceUntilIdle()
        job.cancel()
        advanceUntilIdle()

        verify { mockClient.removeLocationUpdates(any<LocationCallback>()) }
      }
}
