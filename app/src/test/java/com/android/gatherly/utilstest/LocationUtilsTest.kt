package com.android.gatherly.utilstest

import android.content.Context
import android.content.pm.PackageManager
import android.location.Location
import androidx.core.content.ContextCompat
import com.android.gatherly.utils.createLocationRequest
import com.android.gatherly.utils.locationFlow
import com.google.android.gms.location.FusedLocationProviderClient
import com.google.android.gms.location.LocationCallback
import com.google.android.gms.location.LocationRequest
import com.google.android.gms.location.LocationResult
import com.google.android.gms.tasks.Task
import io.mockk.*
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.launch
import kotlinx.coroutines.test.UnconfinedTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.runTest
import org.junit.Assert.*
import org.junit.Test

// This file contains code generated by an LLM (Claude.ai).

/** Unit tests for LocationUtils functions. */
class LocationUtilsTest {

  /** Test that createLocationRequest returns a LocationRequest with the expected configuration. */
  @Test
  fun createLocationRequest_hasCorrectConfiguration() {
    val request = createLocationRequest()

    assertEquals(10000L, request.interval)
    assertEquals(LocationRequest.PRIORITY_HIGH_ACCURACY, request.priority)
  }

  /** Test that locationFlow throws SecurityException when location permission is not granted. */
  @OptIn(ExperimentalCoroutinesApi::class)
  @Test
  fun locationFlow_withoutPermission_throwsSecurityException() =
      runTest(UnconfinedTestDispatcher()) {
        val mockContext = mockk<Context>()
        val mockClient = mockk<FusedLocationProviderClient>()

        every {
          ContextCompat.checkSelfPermission(
              mockContext, android.Manifest.permission.ACCESS_FINE_LOCATION)
        } returns PackageManager.PERMISSION_DENIED

        val flow = mockClient.locationFlow(mockContext)

        try {
          flow.first()
          fail("Expected SecurityException")
        } catch (e: SecurityException) {
          assertEquals("Location permission not granted", e.message)
        }
      }

  /** Test that locationFlow emits Location when location permission is granted. */
  @OptIn(ExperimentalCoroutinesApi::class)
  @Test
  fun locationFlow_withPermission_emitsLocation() =
      runTest(UnconfinedTestDispatcher()) {
        val mockContext = mockk<Context>()
        val mockClient = mockk<FusedLocationProviderClient>(relaxed = true)
        val mockTask = mockk<Task<Void>>(relaxed = true)
        val mockLocation = mockk<Location>()

        every {
          ContextCompat.checkSelfPermission(
              mockContext, android.Manifest.permission.ACCESS_FINE_LOCATION)
        } returns PackageManager.PERMISSION_GRANTED

        every { mockLocation.latitude } returns 46.5197
        every { mockLocation.longitude } returns 6.5663

        var capturedCallback: LocationCallback? = null

        every {
          mockClient.requestLocationUpdates(any(), any<LocationCallback>(), isNull())
        } answers
            {
              capturedCallback = secondArg()
              mockTask
            }

        every { mockClient.removeLocationUpdates(any<LocationCallback>()) } returns mockTask

        val flow = mockClient.locationFlow(mockContext)

        var location: Location? = null
        val job = launch { location = flow.first() }

        assertNotNull("Callback should have been captured", capturedCallback)

        val locationResult = mockk<LocationResult>(relaxed = true)
        every { locationResult.locations } returns listOf(mockLocation)

        capturedCallback?.onLocationResult(locationResult)

        assertNotNull(location)
        assertEquals(46.5197, location!!.latitude, 0.0001)
        assertEquals(6.5663, location!!.longitude, 0.0001)

        job.cancel() // cleanup
      }

  /** Test that locationFlow removes location updates when the flow collection is cancelled. */
  @OptIn(ExperimentalCoroutinesApi::class)
  @Test
  fun locationFlow_onCancellation_removesLocationUpdates() =
      runTest(UnconfinedTestDispatcher()) {
        val mockContext = mockk<Context>()
        val mockClient = mockk<FusedLocationProviderClient>(relaxed = true)
        val mockTask = mockk<Task<Void>>(relaxed = true)

        every {
          ContextCompat.checkSelfPermission(
              mockContext, android.Manifest.permission.ACCESS_FINE_LOCATION)
        } returns PackageManager.PERMISSION_GRANTED

        var capturedCallback: LocationCallback? = null

        every { mockClient.requestLocationUpdates(any(), any<LocationCallback>(), any()) } answers
            {
              capturedCallback = secondArg()
              mockTask
            }

        val flow = mockClient.locationFlow(mockContext)

        val job = launch { flow.collect {} }

        advanceUntilIdle()
        job.cancel()
        advanceUntilIdle()

        verify { mockClient.removeLocationUpdates(any<LocationCallback>()) }
      }
}
