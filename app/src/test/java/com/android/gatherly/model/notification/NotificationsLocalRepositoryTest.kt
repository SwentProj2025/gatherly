package com.android.gatherly.model.notification

import com.android.gatherly.model.notification.NotificationsLocalRepositoryTestData.eventReminders
import com.android.gatherly.model.notification.NotificationsLocalRepositoryTestData.friendRequests
import com.android.gatherly.model.notification.NotificationsLocalRepositoryTestData.todoReminders
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.test.runTest
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test

// This file contains code generated by an LLM (Claude.ai, GitHub Copilot).

class NotificationsLocalRepositoryTest {

  private lateinit var repository: NotificationsLocalRepository

  @Before
  fun setUp() {
    repository = NotificationsLocalRepository()
  }

  /** Helper function to add sample notifications to the repository for testing. */
  private fun addSampleNotifications() = runBlocking {
    repository.addNotification(friendRequests[0]) // userB
    repository.addNotification(friendRequests[1]) // userB
    repository.addNotification(todoReminders[0]) // userA
    repository.addNotification(todoReminders[2]) // userC
    repository.addNotification(eventReminders[0]) // userA
  }

  // ============ Happy Path Tests ============

  @Test
  fun getNewId_returnsUniqueIds() = runTest {
    // Verify that multiple calls to getNewId return unique IDs
    val id1 = repository.getNewId()
    val id2 = repository.getNewId()
    val id3 = repository.getNewId()

    assertNotEquals(id1, id2)
    assertNotEquals(id1, id3)
    assertNotEquals(id2, id3)

    assertEquals("0", id1)
    assertEquals("1", id2)
    assertEquals("2", id3)
  }

  @Test
  fun addNotification_andGetNotification_returnsCorrectNotification() = runTest {
    // Add a notification and retrieve it by ID
    val notification = friendRequests[2]
    repository.addNotification(notification)
    assertEquals(notification, repository.getNotification(notification.id))
  }

  @Test
  fun getUserNotifications_returnsNotificationsForSpecificUser() = runTest {
    // Add multiple notifications for different users
    addSampleNotifications()

    // Retrieve notifications for userB
    val userBNotifications = repository.getUserNotifications("userB")
    assertEquals(2, userBNotifications.size)
    assertTrue(userBNotifications.all { it.recipientId == "userB" })
  }

  @Test
  fun markAsRead_updatesNotificationReadStatus() = runTest {
    // Add notification, mark as read, verify wasRead is true
    repository.addNotification(eventReminders[2])
    repository.markAsRead(eventReminders[2].id)
    val updatedNotification = repository.getNotification(eventReminders[2].id)
    assertTrue(updatedNotification.wasRead)
  }

  @Test
  fun deleteNotification_removesNotification() = runTest {
    // Adding notification
    repository.addNotification(todoReminders[1])
    assertEquals(1, repository.getUserNotifications("userB").size)
    assertEquals(todoReminders[1], repository.getNotification(todoReminders[1].id))
    // Deleting notification
    repository.deleteNotification(todoReminders[1].id)
    // Verifying it's gone
    val userBNotifications = repository.getUserNotifications("userB")
    assertEquals(0, userBNotifications.size)
  }

  // ============ Edge Cases ============

  @Test(expected = NoSuchElementException::class)
  fun getNotification_withInvalidId_throwsException() = runTest {
    // Add multiple notifications for different users
    addSampleNotifications()

    val invalidId = "non_existent_id"
    repository.getNotification(invalidId)
  }

  @Test(expected = NoSuchElementException::class)
  fun markAsRead_withInvalidId_throwsException() = runTest {
    // Add multiple notifications for different users
    addSampleNotifications()

    val invalidId = "non_existent_id"
    repository.markAsRead(invalidId)
  }

  @Test(expected = NoSuchElementException::class)
  fun deleteNotification_withInvalidId_throwsException() = runTest {
    // Add multiple notifications for different users
    addSampleNotifications()

    val invalidId = "non_existent_id"
    repository.deleteNotification(invalidId)
  }

  @Test(expected = IllegalArgumentException::class)
  fun addNotification_withDuplicateId_throwsException() = runTest {
    // Add notification with same ID twice to see if it throws
    repository.addNotification(friendRequests[0])
    repository.addNotification(friendRequests[0])
  }

  @Test
  fun getUserNotifications_withNoNotifications_returnsEmptyList() = runTest {
    // Add multiple notifications for different users
    addSampleNotifications()

    val noNotificationUser = "userE"
    val userENotifications = repository.getUserNotifications(noNotificationUser)
    assertTrue(userENotifications.isEmpty())
  }

  // ============ State Verification ============

  @Test
  fun addNotification_preservesAllFields() = runTest {
    // Add notification, retrieve it, verify all fields match
    repository.addNotification(friendRequests[2])
    assertEquals(friendRequests[2], repository.getNotification(friendRequests[2].id))

    val retrievedNotification = repository.getNotification(friendRequests[2].id)
    assertEquals(friendRequests[2].id, retrievedNotification.id)
    assertEquals(friendRequests[2].type, retrievedNotification.type)
    assertEquals(friendRequests[2].emissionTime, retrievedNotification.emissionTime)
    assertEquals(friendRequests[2].senderId, retrievedNotification.senderId)
    assertEquals(friendRequests[2].relatedEntityId, retrievedNotification.relatedEntityId)
    assertEquals(friendRequests[2].recipientId, retrievedNotification.recipientId)
    assertEquals(friendRequests[2].wasRead, retrievedNotification.wasRead)
  }

  @Test
  fun markAsRead_onlyChangesWasReadField() = runTest {
    // Add notification, mark as read, retrieve it
    repository.addNotification(eventReminders[1])
    assertEquals(eventReminders[1], repository.getNotification(eventReminders[1].id))
    repository.markAsRead(eventReminders[1].id)
    val updatedNotification = repository.getNotification(eventReminders[1].id)

    // Verify other fields remain unchanged after marking as read
    assertTrue(updatedNotification.wasRead)
    assertEquals(eventReminders[1].id, updatedNotification.id)
    assertEquals(eventReminders[1].type, updatedNotification.type)
    assertEquals(eventReminders[1].emissionTime, updatedNotification.emissionTime)
    assertEquals(eventReminders[1].senderId, updatedNotification.senderId)
    assertEquals(eventReminders[1].relatedEntityId, updatedNotification.relatedEntityId)
    assertEquals(eventReminders[1].recipientId, updatedNotification.recipientId)
  }

  // ============ Ordering ============

  @Test
  fun getUserNotifications_returnsNotificationsInDescendingTimeOrder() = runTest {
    // Add multiple notifications with different timestamps
    addSampleNotifications()

    // Retrieve notifications for userA
    val userANotifications = repository.getUserNotifications("userA")
    assertEquals(2, userANotifications.size)

    // Verify they are in descending order by emissionTime
    assertEquals(userANotifications.sortedByDescending { it.emissionTime }, userANotifications)
  }
}
