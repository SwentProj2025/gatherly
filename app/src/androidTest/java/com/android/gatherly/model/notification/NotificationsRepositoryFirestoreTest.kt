package com.android.gatherly.model.notification

import com.android.gatherly.utils.FirestoreNotificationsGatherlyTest
import kotlin.time.Duration.Companion.seconds
import kotlinx.coroutines.test.runTest
import org.junit.Assert.*
import org.junit.Test

// This class contains code generated by an LLM (Claude.ai, GitHub Copilot).

/**
 * Instrumented test suite for [NotificationsRepositoryFirestore].
 */
class NotificationsRepositoryFirestoreTest : FirestoreNotificationsGatherlyTest() {

  // Happy Path Tests:

    /**
     * Verifies that [NotificationsRepository.getNewId] generates unique,
     * non-empty identifiers for notifications.
     */
  @Test
  fun getNewId_returnsUniqueNonEmptyIds() =
      runTest {
        // Call getNewId() multiple times
        val id1 = repository.getNewId()
        val id2 = repository.getNewId()
        val id3 = repository.getNewId()

        // Verify all IDs are non-empty
        assertTrue(id1.isNotEmpty())
        assertTrue(id2.isNotEmpty())
        assertTrue(id3.isNotEmpty())

        // Verify all IDs are unique
        assertEquals(3, setOf(id1, id2, id3).size)
      }

    /**
     * Verifies that a notification added to Firestore can be retrieved
     * by its ID with all fields preserved.
     */
  @Test
  fun addNotification_andGetNotification_returnsCorrectNotification() =
      runTest {
        // Create a notification using a template with user1 as recipient
        val newId = repository.getNewId()
        val notification =
            friendRequest1_template.copy(id = newId, senderId = user2Id, recipientId = user1Id)
        // Add the notification
        repository.addNotification(notification)

        // Get the notification by ID
        val retrievedNotification = repository.getNotification(newId)

        // Assert they are equal
        assertEquals(notification, retrievedNotification)
      }

    /**
     * Verifies that [NotificationsRepository.getUserNotifications] only returns
     * notifications belonging to the currently authenticated user.
     */
  @Test
  fun getUserNotifications_returnsNotificationsForCurrentUserOnly() =
      runTest {
        // Add multiple notifications for user1 (reminder: user1 is signed in by default)
        val notification1 =
            friendRequest1_template.copy(
                id = repository.getNewId(), senderId = user2Id, recipientId = user1Id)
        val notification2 =
            friendRequest2_template.copy(
                id = repository.getNewId(), senderId = user3Id, recipientId = user1Id)
        repository.addNotification(notification1)
        repository.addNotification(notification2)

        // Sign in as user2, add notification
        signInWithToken(user2Token)
        val notification3 =
            todoReminder1_template.copy(id = repository.getNewId(), recipientId = user2Id)
        repository.addNotification(notification3)

        // Log in as user1, call getUserNotifications(user1Id)
        signInWithToken(user1Token)
        val user1Notifications = repository.getUserNotifications(user1Id)

        // Assert we get only the 2 notifications for user1, and they have correct recipientId
        assertEquals(2, user1Notifications.size)
        assertTrue(user1Notifications.all { it.recipientId == user1Id })
      }

    /**
     * Verifies that calling [NotificationsRepository.markAsRead] updates
     * the read status of a notification.
     */
  @Test
  fun markAsRead_updatesNotificationReadStatus() =
      runTest {
        // Create a notification (default wasRead = false), recipientId = user1Id
        val newId = repository.getNewId()
        val notification = todoReminder2_template.copy(id = newId, recipientId = user1Id)

        // Add the notification
        repository.addNotification(notification)

        // Call markAsRead with the notification ID
        repository.markAsRead(newId)

        // Get the notification again
        val updatedNotification = repository.getNotification(newId)

        // Assert wasRead is now true
        assertTrue(updatedNotification.wasRead)
      }

    /**
     * Verifies that deleting a notification removes it from Firestore
     * and from the user's notification list.
     */
  @Test
  fun deleteNotification_removesNotification() =
      runTest {
        // Add a notification for user1
        val notification =
            todoReminder1_template.copy(id = repository.getNewId(), recipientId = user1Id)
        repository.addNotification(notification)

        // Verify it exists by getting user1's notifications (should have 1)
        var userNotifications = repository.getUserNotifications(user1Id)
        assertEquals(1, userNotifications.size)

        // Delete the notification
        repository.deleteNotification(notification.id)

        // Verify getUserNotifications returns empty list
        userNotifications = repository.getUserNotifications(user1Id)
        assertTrue(userNotifications.isEmpty())
      }

  // Security Tests:

    /**
     * Verifies that attempting to fetch notifications for another user is not allowed and
     * throws a [SecurityException].
     */
  @Test(expected = SecurityException::class)
  fun getUserNotifications_forDifferentUser_throwsSecurityException() =
      runTest {
        // Add a notification for user2
        signInWithToken(user2Token)
        val notification =
            eventReminder1_template.copy(id = repository.getNewId(), recipientId = user2Id)
        repository.addNotification(notification)

        // Try to get user2's notifications while signed in as user1
        signInWithToken(user1Token)
        repository.getUserNotifications(user2Id) // should throw SecurityException
      }

    /**
     * Verifies that accessing a notification belonging to another user is not allowed and
     * throws a [NoSuchElementException].
     */
  @Test(expected = NoSuchElementException::class)
  fun getNotification_forDifferentUser_throwsNoSuchElementException() =
      runTest {
        // Add a notification for user2
        signInWithToken(user2Token)
        val newId = repository.getNewId()
        val notification = eventReminder2_template.copy(id = newId, recipientId = user2Id)
        repository.addNotification(notification)

        // Sign back in as user1, try to get that notification by ID
        signInWithToken(user1Token)
        repository.getNotification(newId) // should throw NoSuchElementException
      }

    /**
     * Verifies that deleting another user's notification is not allowed
     * and throws a [NoSuchElementException].
     */
  @Test(expected = NoSuchElementException::class)
  fun deleteNotification_forDifferentUser_throwsException() =
      runTest {
        // Add a notification for user2
        signInWithToken(user2Token)
        val newId = repository.getNewId()
        val notification = eventReminder2_template.copy(id = newId, recipientId = user2Id)
        repository.addNotification(notification)
        // Sign back in as user1
        signInWithToken(user1Token)

        // Try to delete user2's notification while signed in as user1
        repository.deleteNotification(newId) // should throw NoSuchElementException
      }

    /**
     * Verifies that marking another user's notification as read
     * is not allowed and throws a [NoSuchElementException].
     */
  @Test(expected = NoSuchElementException::class)
  fun markAsRead_forDifferentUser_throwsException() =
      runTest {
        // Add a notification for user2
        signInWithToken(user2Token)
        val newId = repository.getNewId()
        val notification = eventReminder2_template.copy(id = newId, recipientId = user2Id)
        repository.addNotification(notification)
        // Sign back in as user1
        signInWithToken(user1Token)

        // Try to mark user2's notification as read while signed in as user1
        repository.markAsRead(newId) // should throw NoSuchElementException
      }

  // Edge Cases

    /**
     * Verifies that requesting a notification with an invalid ID
     * throws a [NoSuchElementException].
     */
  @Test(expected = NoSuchElementException::class)
  fun getNotification_withInvalidId_throwsException() =
      runTest {
        // Add some notification for user1
        val newId = repository.getNewId()
        val notification = todoReminder1_template.copy(id = newId, recipientId = user1Id)
        repository.addNotification(notification)

        // Try to get a notification with non-existent ID
        repository.getNotification("non_existent_id") // should throw NoSuchElementException
      }

    /**
     * Verifies that marking a non-existent notification as read
     * throws a [NoSuchElementException].
     */
  @Test(expected = NoSuchElementException::class)
  fun markAsRead_withInvalidId_throwsException() =
      runTest {
        // Add some notification for user1
        val newId = repository.getNewId()
        val notification = todoReminder1_template.copy(id = newId, recipientId = user1Id)
        repository.addNotification(notification)

        // Try to mark a notification with non-existent ID as read
        repository.markAsRead("non_existent_id") // should throw NoSuchElementException
      }

    /**
     * Verifies that deleting a non-existent notification
     * throws a [NoSuchElementException].
     */
  @Test(expected = NoSuchElementException::class)
  fun deleteNotification_withInvalidId_throwsException() =
      runTest {
        // Add some notification for user1
        val newId = repository.getNewId()
        val notification = todoReminder1_template.copy(id = newId, recipientId = user1Id)
        repository.addNotification(notification)

        // Try to delete a notification with non-existent ID
        repository.deleteNotification("non_existent_id") // should throw NoSuchElementException
      }

    /**
     * Verifies that retrieving notifications for a user
     * with no notifications returns an empty list.
     */
  @Test
  fun getUserNotifications_withNoNotifications_returnsEmptyList() =
      runTest {
        // Get user 1's notifications, assert they're empty
        val userNotifications = repository.getUserNotifications(user1Id)
        assertTrue(userNotifications.isEmpty())
      }

    /**
     * Verifies that adding a notification with an empty recipient ID
     * is rejected with an [IllegalArgumentException].
     */
  @Test(expected = IllegalArgumentException::class)
  fun addNotification_withEmptyRecipientId_throwsException() =
      runTest {
        val notification =
            friendRequest1_template.copy(
                id = repository.getNewId(), senderId = user2Id, recipientId = "")
        // Try to add it
        repository.addNotification(notification) // should throw IllegalArgumentException
      }

  // State Verification

    /**
     * Verifies that all fields of a notification are preserved
     * when stored and retrieved from Firestore.
     */
  @Test
  fun addNotification_preservesAllFields() =
      runTest {
        // Create and add notification with all fields populated
        val newId = repository.getNewId()
        val notification = eventReminder1_template.copy(id = newId, recipientId = user1Id)
        repository.addNotification(notification)

        // Retrieve it
        val retrievedNotification = repository.getNotification(newId)

        // Assert all fields match
        assertEquals(notification.id, retrievedNotification.id)
        assertEquals(notification.type, retrievedNotification.type)
        assertEquals(notification.emissionTime, retrievedNotification.emissionTime)
        assertEquals(notification.senderId, retrievedNotification.senderId)
        assertEquals(notification.relatedEntityId, retrievedNotification.relatedEntityId)
        assertEquals(notification.recipientId, retrievedNotification.recipientId)
        assertEquals(notification.wasRead, retrievedNotification.wasRead)
      }

    /**
     * Verifies that marking a notification as read only changes
     * the wasRead field and leaves all other fields untouched.
     */
  @Test
  fun markAsRead_onlyChangesWasReadField() =
      runTest {
        // Add a notification with wasRead = false (default)
        val newId = repository.getNewId()
        val notification = todoReminder2_template.copy(id = newId, recipientId = user1Id)
        repository.addNotification(notification)

        // Mark it as read
        repository.markAsRead(newId)

        // Retrieve it
        val updatedNotification = repository.getNotification(newId)

        // Check wasRead is true, other fields unchanged
        assertTrue(updatedNotification.wasRead)
        assertEquals(notification.id, updatedNotification.id)
        assertEquals(notification.type, updatedNotification.type)
        assertEquals(notification.emissionTime, updatedNotification.emissionTime)
        assertEquals(notification.senderId, updatedNotification.senderId)
        assertEquals(notification.relatedEntityId, updatedNotification.relatedEntityId)
        assertEquals(notification.recipientId, updatedNotification.recipientId)
      }

  // Ordering

    /**
     * Verifies that notifications returned by
     * [NotificationsRepository.getUserNotifications] are ordered
     * by emission time in descending order.
     */
  @Test
  fun getUserNotifications_returnsNotificationsInDescendingTimeOrder() =
      runTest {
        // Adding multiple notifications for user1, each with different emissionTime values
        val notification1 =
            friendRequest1_template.copy(
                id = repository.getNewId(),
                senderId = user2Id,
                recipientId = user1Id) // time = 1000
        val notification2 =
            todoReminder1_template.copy(
                id = repository.getNewId(), recipientId = user1Id) // time = 4000
        val notification3 =
            eventReminder1_template.copy(
                id = repository.getNewId(), recipientId = user1Id) // time = 7000

        repository.addNotification(notification1)
        repository.addNotification(notification2)
        repository.addNotification(notification3)

        // Getting notifications, verifying order
        val userNotifications = repository.getUserNotifications(user1Id)

        assertEquals(3, userNotifications.size)
        for (i in 0 until userNotifications.size - 1) {
          val current = userNotifications[i]
          val next = userNotifications[i + 1]
          assertTrue(current.emissionTime.seconds <= next.emissionTime.seconds)
        }
      }
}
