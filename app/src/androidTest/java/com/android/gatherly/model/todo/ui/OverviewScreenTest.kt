package com.android.gatherly.ui.todo

import androidx.compose.ui.semantics.SemanticsProperties
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.assertIsNotDisplayed
import androidx.compose.ui.test.assertIsOff
import androidx.compose.ui.test.assertIsOn
import androidx.compose.ui.test.hasTestTag
import androidx.compose.ui.test.hasText
import androidx.compose.ui.test.junit4.createComposeRule
import androidx.compose.ui.test.onAllNodesWithTag
import androidx.compose.ui.test.onNodeWithTag
import androidx.compose.ui.test.performClick
import androidx.compose.ui.test.performScrollToNode
import com.android.gatherly.model.todo.ToDo
import com.android.gatherly.model.todo.ToDoStatus
import com.android.gatherly.utils.InMemoryGatherlyTest
import com.google.firebase.Timestamp
import java.util.Calendar
import kotlin.collections.last
import kotlinx.coroutines.test.runTest
import org.junit.Rule
import org.junit.Test

// Portions of the code in this file are copy-pasted from the Bootcamp solution provided by the
// SwEnt staff.

class OverviewScreenTest : InMemoryGatherlyTest() {
  @get:Rule val composeTestRule = createComposeRule()

  fun setContent(withInitialTodos: List<ToDo> = emptyList()) {
    runTest { withInitialTodos.forEach { repository.addTodo(it) } }
    composeTestRule.setContent { OverviewScreen() }
  }

  @Test
  fun testTagsCorrectlySetWhenListIsEmpty() {
    setContent()
    composeTestRule.onNodeWithTag(OverviewScreenTestTags.TODO_LIST).assertIsNotDisplayed()
    composeTestRule.onNodeWithTag(OverviewScreenTestTags.EMPTY_TODO_LIST_MSG).assertIsDisplayed()
  }

  @Test
  fun testTagsCorrectlySetWhenListIsNotEmpty() {
    setContent(withInitialTodos = listOf(todo1, todo2, todo3))
    composeTestRule.onNodeWithTag(OverviewScreenTestTags.TODO_LIST).assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(OverviewScreenTestTags.getTestTagForTodoItem(todo1))
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(OverviewScreenTestTags.getTestTagForTodoItem(todo2))
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(OverviewScreenTestTags.getTestTagForTodoItem(todo3))
        .assertIsDisplayed()
  }

  @Test
  fun todoListDisplaysTaskName() {
    val todoList = listOf(todo1)
    setContent(withInitialTodos = todoList)
    composeTestRule.onTodoItem(todo1, hasText(todo1.name))
  }

  @Test
  fun todoListDisplaysDueDate() {
    val todo = todo1.copy(dueDate = Timestamp.fromDate(2023, Calendar.DECEMBER, 25))
    val todoList = listOf(todo)
    val dueDate = "25/12/2023"
    setContent(withInitialTodos = todoList)
    composeTestRule.onTodoItem(todo, hasText(dueDate))
  }

  @Test
  fun todoListDisplaysExistingTodos() {
    val todoList = listOf(todo1, todo2)
    setContent(withInitialTodos = todoList)
    // Check that each todo item is displayed.
    todoList.forEach { composeTestRule.onTodoItem(it, hasText(it.name)) }
  }

  @Test
  fun dueDateIsCorrectlyFormatted() {
    val todo1 = todo1.copy(uid = "1", dueDate = Timestamp.fromDate(2023, Calendar.DECEMBER, 25))
    val todoList = listOf(todo1)
    val dueDate1 = "25/12/2023"
    setContent(withInitialTodos = todoList)
    composeTestRule.onTodoItem(todo1, hasText(dueDate1))
  }

  @Test
  fun canScrollOnTheTodoList() {
    val todos =
        (1..50).toList<Int>().map { todo1.copy(uid = it.toString(), name = "${todo1.name} #$it") }
    setContent(withInitialTodos = todos)
    composeTestRule
        .onNodeWithTag(OverviewScreenTestTags.getTestTagForTodoItem(todos.first()))
        .assertIsDisplayed()
    val lastNode =
        composeTestRule.onNodeWithTag(OverviewScreenTestTags.getTestTagForTodoItem(todos.last()))
    lastNode.assertIsNotDisplayed()
    composeTestRule
        .onNodeWithTag(OverviewScreenTestTags.TODO_LIST)
        .performScrollToNode(hasTestTag(OverviewScreenTestTags.getTestTagForTodoItem(todos.last())))
    lastNode.assertIsDisplayed()
  }

  // Portions of the code in this test were generated by an LLM.
  @Test
  fun checkboxTogglesTodoStatusBetweenOngoingAndCompleted() {
    // create a single ongoing todo
    val todo = todo1.copy(status = ToDoStatus.ONGOING)
    setContent(withInitialTodos = listOf(todo))

    val checkboxTag = OverviewScreenTestTags.getCheckboxTagForTodoItem(todo)

    // checkbox is not checked (Ongoing section)
    composeTestRule.onNodeWithTag(checkboxTag).assertExists().assertIsOff()

    // click the checkbox to mark it as completed
    composeTestRule.onNodeWithTag(checkboxTag).performClick()

    // todo should now appear in the Completed section (checked)
    composeTestRule.waitUntil(timeoutMillis = 5_000) {
      // Wait until UI recomposes with updated status
      composeTestRule.onAllNodesWithTag(checkboxTag).fetchSemanticsNodes().any {
        it.config.contains(SemanticsProperties.ToggleableState)
      }
    }

    composeTestRule.onNodeWithTag(checkboxTag).assertIsOn()

    // uncheck to mark it as ongoing again
    composeTestRule.onNodeWithTag(checkboxTag).performClick()

    // should return to Ongoing section (unchecked)
    composeTestRule.waitUntil(timeoutMillis = 5_000) {
      composeTestRule.onAllNodesWithTag(checkboxTag).fetchSemanticsNodes().isNotEmpty()
    }

    composeTestRule.onNodeWithTag(checkboxTag).assertIsOff()
  }
}
