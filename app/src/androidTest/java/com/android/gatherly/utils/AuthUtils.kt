package com.android.gatherly.utils

import android.content.Context
import android.util.Base64
import androidx.core.os.bundleOf
import androidx.credentials.CredentialManager
import androidx.credentials.CustomCredential
import androidx.credentials.GetCredentialRequest
import androidx.credentials.GetCredentialResponse
import com.google.android.libraries.identity.googleid.GoogleIdTokenCredential
import com.google.android.libraries.identity.googleid.GoogleIdTokenCredential.Companion.TYPE_GOOGLE_ID_TOKEN_CREDENTIAL
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.FirebaseUser
import io.mockk.Runs
import io.mockk.coEvery
import io.mockk.every
import io.mockk.just
import io.mockk.mockk
import io.mockk.mockkObject
import org.json.JSONObject
import org.mockito.Mockito.mock
import org.mockito.Mockito.`when`

// This file contains code generated by an LLM.

/**
 * Utility object for generating fake JWT tokens for testing purposes.
 *
 * This generator creates properly formatted but unsigned JWT tokens that can be used in test
 * environments where actual Google authentication is not available or desired.
 */
object FakeJwtGenerator {
  /**
   * Encodes a byte array to a Base64 URL-safe string without padding.
   *
   * @param input The byte array to encode
   * @return A Base64 URL-safe encoded string suitable for JWT components
   */
  private fun base64UrlEncode(input: ByteArray): String {
    return Base64.encodeToString(input, Base64.URL_SAFE or Base64.NO_PADDING or Base64.NO_WRAP)
  }

  /**
   * Creates a fake Google ID token with the specified user information.
   *
   * The generated token follows the JWT format (header.payload.signature) but uses a dummy
   * signature since validation is not required in test environments.
   *
   * @param name The display name for the fake user
   * @param email The email address for the fake user
   * @return A formatted JWT string containing the user's information
   */
  fun createFakeGoogleIdToken(name: String, email: String): String {
    val header = JSONObject(mapOf("alg" to "none"))
    val payload =
        JSONObject(
            mapOf(
                "sub" to email.hashCode().toString(), // was counter.toString()
                "email" to email,
                "name" to name,
                "picture" to "http://example.com/avatar.png"))

    val headerEncoded = base64UrlEncode(header.toString().toByteArray())
    val payloadEncoded = base64UrlEncode(payload.toString().toByteArray())

    // Signature can be anything, emulator doesn't check it
    val signature = "sig"

    return "$headerEncoded.$payloadEncoded.$signature"
  }
}

/**
 * A mock implementation of CredentialManager for testing authentication flows.
 *
 * This class creates a fake CredentialManager that returns predefined credentials without requiring
 * actual Google Sign-In infrastructure, enabling isolated unit tests.
 *
 * @property context The Android context (unused but required for delegation)
 */
class FakeCredentialManager private constructor(private val context: Context) :
    CredentialManager by CredentialManager.create(context) {
  companion object {
    /**
     * Creates a mock CredentialManager that returns a fake Google ID token credential.
     *
     * This factory method sets up all necessary mocks using MockK to simulate the credential
     * retrieval flow. When `getCredential()` is called on the returned CredentialManager, it will
     * always return a CustomCredential containing the provided fake token.
     *
     * @param fakeUserIdToken The fake JWT token to be returned by the mock credential manager
     * @return A mocked CredentialManager configured to return the specified fake credential
     */
    fun create(fakeUserIdToken: String): CredentialManager {
      mockkObject(GoogleIdTokenCredential)
      val googleIdTokenCredential = mockk<GoogleIdTokenCredential>()
      every { googleIdTokenCredential.idToken } returns fakeUserIdToken
      every { GoogleIdTokenCredential.createFrom(any()) } returns googleIdTokenCredential
      val fakeCredentialManager = mockk<FakeCredentialManager>()
      val mockGetCredentialResponse = mockk<GetCredentialResponse>()

      val fakeCustomCredential =
          CustomCredential(
              type = TYPE_GOOGLE_ID_TOKEN_CREDENTIAL,
              data = bundleOf("id_token" to fakeUserIdToken))

      every { mockGetCredentialResponse.credential } returns fakeCustomCredential
      coEvery {
        fakeCredentialManager.getCredential(any<Context>(), any<GetCredentialRequest>())
      } returns mockGetCredentialResponse
      coEvery { fakeCredentialManager.clearCredentialState(any()) } just Runs

      return fakeCredentialManager
    }
  }
}

/** This class is used to mock Firebase Authentication */
class MockitoUtils {
  lateinit var mockAuth: FirebaseAuth
  lateinit var mockUser: FirebaseUser

  init {
    initMockAuthAndUser()
  }

  /** To be called first. Defines the kind of classes mockAuth and mockUser mock */
  private fun initMockAuthAndUser() {
    mockAuth = mock(FirebaseAuth::class.java)
    mockUser = mock(FirebaseUser::class.java)
  }

  /**
   * Defines the currentUser returned when mocking. Also defines the authentication means of the
   * user
   *
   * @param currentUser the current user string chosen for testing
   * @param isAnon defines if a user is anonymously connected when mocking
   */
  fun chooseCurrentUser(currentUser: String, isAnon: Boolean = false) {
    `when`(mockAuth.currentUser).thenReturn(mockUser)
    `when`(mockUser.uid).thenReturn(currentUser)
    `when`(mockUser.isAnonymous).thenReturn(isAnon)
  }

  /** For tests that want to test with an unauthenticated user */
  fun unauthenticatedCurrentUser() {
    `when`(mockAuth.currentUser).thenReturn(null)
  }
}
