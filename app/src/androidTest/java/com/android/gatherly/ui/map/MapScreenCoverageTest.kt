package com.android.gatherly.ui.map

import android.Manifest
import androidx.activity.ComponentActivity
import androidx.activity.result.ActivityResultRegistry
import androidx.activity.result.ActivityResultRegistryOwner
import androidx.activity.result.contract.ActivityResultContract
import androidx.compose.runtime.CompositionLocalProvider
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.core.app.ActivityOptionsCompat
import com.android.gatherly.model.event.EventsLocalRepository
import com.android.gatherly.model.todo.ToDosLocalRepository
import com.google.android.gms.location.FusedLocationProviderClient
import io.mockk.coEvery
import io.mockk.coVerify
import io.mockk.every
import io.mockk.spyk
import io.mockk.verify
import org.junit.Rule
import org.junit.Test

// This test contains code generated by an LLM (Gemini, GitHub Copilot).

/**
 * Instrumentation test focused on the "Slow Path" of MapScreen initialization.
 *
 * Unlike [MapScreenTest], which forces permissions to be GRANTED immediately via a Rule, this test
 * simulates the initial DENIED state and verifies the logic flow when the user subsequently grants
 * permissions via the system dialog.
 *
 * It uses a [ActivityResultRegistry] interception pattern to simulate system dialog responses
 * without UI Automator.
 */
class MapScreenCoverageTest {

  @get:Rule val compose = createAndroidComposeRule<ComponentActivity>()

  /**
   * Verifies that when the permission launcher callback receives a "Granted" result, the ViewModel
   * correctly triggers location updates and camera initialization.
   *
   * This covers the lines of code inside the `rememberLauncherForActivityResult` callback.
   */
  @Test
  fun permissionCallback_whenGranted_callsStartLocationUpdates() {
    // =========================================================================================
    // STEP 1: Dependencies & Spy Creation
    // =========================================================================================

    // We use concrete Local Repositories instead of Mocks.
    // On Android Instrumented tests, MockK often fails to create proxies for Interfaces
    // (like ToDosRepository), causing 'IncompatibleClassChangeError'.
    // Using real, empty local repos avoids this proxy generation entirely.
    val todoRepo = ToDosLocalRepository()
    val eventsRepo = EventsLocalRepository()

    // We pass null for the FusedLocationProviderClient.
    // Google Play Services classes are final and hard to mock.
    // Since we are about to stub the methods that use this client, the ViewModel
    // will never actually try to access this null reference.
    val locationClient: FusedLocationProviderClient? = null

    // We create a real instance of the ViewModel.
    val realViewModel = MapViewModel(todoRepo, eventsRepo, locationClient)

    // We wrap the real ViewModel in a SPY ('spyk').
    // Why? A standard 'mockk()' fails because it tries to proxy the 'uiState' (StateFlow)
    // interface, leading to crashes on Android.
    // A spy uses the real object for properties (like uiState), but allows us to
    // intercept/stub specific function calls (like startLocationUpdates).
    val spyViewModel = spyk(realViewModel)

    // =========================================================================================
    // STEP 2: Behavior Stubbing
    // =========================================================================================

    // We verify that these methods are called, but we prevent them from running.
    // Returning 'Unit' ensures we don't hit the null locationClient or trigger logic
    // that requires real device sensors.
    every { spyViewModel.startLocationUpdates(any()) } returns Unit
    coEvery { spyViewModel.initialiseCameraPosition(any()) } returns Unit

    // =========================================================================================
    // STEP 3: The Fake Registry (The Interceptor)
    // =========================================================================================

    var wasLaunchCalled = false
    var requestedPermissions = emptyArray<String>()

    // This custom Registry acts as a "Man-in-the-Middle" between the App and the OS.
    val fakeRegistry =
        object : ActivityResultRegistry() {
          override fun <I, O> onLaunch(
              requestCode: Int,
              contract: ActivityResultContract<I, O>,
              input: I,
              options: ActivityOptionsCompat?
          ) {
            wasLaunchCalled = true

            // Capture the permissions the app requested to ensure we are asking for FINE + COARSE
            @Suppress("UNCHECKED_CAST")
            requestedPermissions = input as Array<String>

            // SIMULATION: Instead of showing a UI dialog, we immediately reply to the app
            // saying "The user clicked allow for both permissions".
            dispatchResult(
                requestCode,
                mapOf(
                    Manifest.permission.ACCESS_FINE_LOCATION to true,
                    Manifest.permission.ACCESS_COARSE_LOCATION to true))
          }
        }

    // The Owner is the vehicle that delivers our Fake Registry to the Composable
    val registryOwner =
        object : ActivityResultRegistryOwner {
          override val activityResultRegistry = fakeRegistry
        }

    // =========================================================================================
    // STEP 4: Execution & Composition Injection
    // =========================================================================================

    compose.setContent {
      // We use CompositionLocalProvider to inject our Fake Registry.
      // When MapScreen calls 'rememberLauncher...', it will find OUR registry instead
      // of the default Android system registry.
      CompositionLocalProvider(
          androidx.activity.compose.LocalActivityResultRegistryOwner provides registryOwner) {
            MapScreen(viewModel = spyViewModel)
          }
    }

    // =========================================================================================
    // STEP 5: Verification
    // =========================================================================================

    // Wait for idle
    compose.waitForIdle()

    // Assertion 1: Did the app actually try to ask for permissions? (Covers the 'else' block)
    assert(wasLaunchCalled)

    // Assertion 2: Did we ask for BOTH permissions? (Verifies Android 12+ fix)
    assert(requestedPermissions.contains(Manifest.permission.ACCESS_FINE_LOCATION))
    assert(requestedPermissions.contains(Manifest.permission.ACCESS_COARSE_LOCATION))

    // Assertion 3: Did the callback fire and trigger the ViewModel? (Covers the callback block)
    verify { spyViewModel.startLocationUpdates(any()) }
    coVerify { spyViewModel.initialiseCameraPosition(any()) }
  }
}
