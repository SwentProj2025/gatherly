package com.android.gatherly.ui.homepage

import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.assertIsNotDisplayed
import androidx.compose.ui.test.hasTestTag
import androidx.compose.ui.test.junit4.createComposeRule
import androidx.compose.ui.test.onNodeWithTag
import androidx.compose.ui.test.performClick
import androidx.compose.ui.test.performScrollToNode
import com.android.gatherly.model.event.EventsLocalRepository
import com.android.gatherly.model.notification.NotificationsLocalRepository
import com.android.gatherly.model.notification.NotificationsRepository
import com.android.gatherly.model.points.PointsLocalRepository
import com.android.gatherly.model.points.PointsRepository
import com.android.gatherly.model.profile.Profile
import com.android.gatherly.model.profile.ProfileLocalRepository
import com.android.gatherly.model.profile.ProfileStatus
import com.android.gatherly.model.todo.ToDo
import com.android.gatherly.model.todo.ToDoStatus
import com.android.gatherly.model.todo.ToDosLocalRepository
import com.android.gatherly.ui.homePage.HomePageScreen
import com.android.gatherly.ui.homePage.HomePageScreenActions
import com.android.gatherly.ui.homePage.HomePageScreenTestTags
import com.android.gatherly.ui.homePage.HomePageViewModel
import com.android.gatherly.ui.homePage.getFriendProfilePicTestTag
import com.android.gatherly.ui.homePage.getFriendStatusTestTag
import com.android.gatherly.ui.homePage.getTaskItemTestTag
import com.android.gatherly.utils.MapCoordinator
import com.android.gatherly.utils.MockitoUtils
import com.google.firebase.Timestamp
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test

// Some parts of the code in this file are generated by ChatGPT. (e.g. documentation)

/**
 * UI tests for [HomePageScreen].
 *
 * These tests ensure that key components of the Home Page are displayed and interactable, including
 * tasks, buttons, map, and friends section.
 */
class HomePageScreenTest {

  val friend1 = HomePageScreenTestData.friend1
  val friend2 = HomePageScreenTestData.friend2
  val todo1 = HomePageScreenTestData.todo1
  val currentProfile = HomePageScreenTestData.currentProfile

  @get:Rule val composeRule = createComposeRule()

  private lateinit var fakeViewModel: HomePageViewModel
  private lateinit var todosLocalRepo: ToDosLocalRepository
  private lateinit var eventsLocalRepo: EventsLocalRepository
  private lateinit var profileLocalRepo: ProfileLocalRepository
  private lateinit var notificationsRepository: NotificationsRepository
  private lateinit var pointsRepository: PointsRepository
  private lateinit var mockitoUtils: MockitoUtils
  private lateinit var mapCoordinator: MapCoordinator

  @Before
  fun setUp() {
    runTest {
      todosLocalRepo = ToDosLocalRepository()
      eventsLocalRepo = EventsLocalRepository()
      profileLocalRepo = ProfileLocalRepository()
      notificationsRepository = NotificationsLocalRepository()
      pointsRepository = PointsLocalRepository()
      mapCoordinator = MapCoordinator()
      populateRepositories()
    }
  }

  /**
   * Sets the HomePageScreen content with a mocked Firebase authentication context.
   *
   * Initializes a [HomePageViewModel] backed by local repositories and injects a mocked
   * authenticated user before rendering the screen.
   */
  private fun setContentWithGoogle() {
    // Mock Firebase Auth
    mockitoUtils = MockitoUtils()
    mockitoUtils.chooseCurrentUser(currentProfile.uid)
    fakeViewModel =
        HomePageViewModel(
            toDosRepository = todosLocalRepo,
            eventsRepository = eventsLocalRepo,
            profileRepository = profileLocalRepo,
            notificationsRepository = notificationsRepository,
            pointsRepository = pointsRepository,
            authProvider = { mockitoUtils.mockAuth })
    composeRule.setContent {
      HomePageScreen(
          homePageViewModel = fakeViewModel,
          homePageScreenActions = HomePageScreenActions(),
          coordinator = mapCoordinator)
    }
  }

  /** Populates local repositories with fake data for testing. */
  private fun populateRepositories() = runBlocking {
    todosLocalRepo.addTodo(todo1)
    profileLocalRepo.addProfile(friend1)
    profileLocalRepo.addProfile(friend2)
    profileLocalRepo.addProfile(currentProfile)
  }

  /** Verifies that all main UI components are visible and interactable. */
  @Test
  fun componentsAreDisplayed() {
    setContentWithGoogle()
    composeRule.onNodeWithTag(HomePageScreenTestTags.UPCOMING_EVENTS_TITLE).assertIsDisplayed()
    composeRule.onNodeWithTag(HomePageScreenTestTags.UPCOMING_TASKS_TITLE).assertIsDisplayed()
    composeRule.onNodeWithTag(HomePageScreenTestTags.FOCUS_TIMER_TEXT).assertIsDisplayed()
    composeRule.onNodeWithTag(HomePageScreenTestTags.FOCUS_BUTTON).assertIsDisplayed()
    composeRule.onNodeWithTag(HomePageScreenTestTags.FOCUS_BUTTON).performClick()
    composeRule.onNodeWithTag(HomePageScreenTestTags.MINIMAP_BUTTON, useUnmergedTree = true)
  }

  /** Ensures that the focus button is visible and can be clicked without crashing. */
  @Test
  fun focusButton_isClickable() {
    setContentWithGoogle()
    composeRule
        .onNodeWithTag(HomePageScreenTestTags.FOCUS_BUTTON)
        .assertIsDisplayed()
        .performClick()
  }

  /** Verifies that task items from the ViewModelâ€™s state are rendered in the UI. */
  @Test
  fun taskItemsAreDisplayed() {
    setContentWithGoogle()
    fakeViewModel.uiState.value.todos.forEach { todo ->
      composeRule.onNodeWithTag(getTaskItemTestTag(todo.uid)).assertIsDisplayed()
    }
  }

  /** Confirms that task items exist in the composition tree for each todo in the state. */
  @Test
  fun taskItemsTextMatchesUiState() {
    setContentWithGoogle()
    fakeViewModel.uiState.value.todos.forEach { todo ->
      composeRule.onNodeWithTag(getTaskItemTestTag(todo.uid)).assertIsDisplayed()
    }
  }

  /** Checks that each task item can be clicked without causing errors. */
  @Test
  fun taskItem_isClickable() {
    setContentWithGoogle()
    fakeViewModel.uiState.value.todos.forEach { todo ->
      composeRule.onNodeWithTag(getTaskItemTestTag(todo.uid)).assertIsDisplayed().performClick()
    }
  }

  /** Ensures the friends section is visible on the screen. */
  @Test
  fun friendsSection_isDisplayed_withAvatars() {
    setContentWithGoogle()
    composeRule.onNodeWithTag(HomePageScreenTestTags.FRIENDS_SECTION).assertIsDisplayed()
  }

  /** Verifies that the mini map is rendered and responds to click interactions. */
  @Test
  fun miniMap_isDisplayed_andClickable() {
    setContentWithGoogle()
    composeRule
        .onNodeWithTag(HomePageScreenTestTags.MINI_MAP_CARD)
        .assertIsDisplayed()
        .performClick()
  }

  /** Verifies that an anonymous user has no friends section displayed */
  @Test
  fun anonUserHasNoFriends() {
    // Create Screen with anonymous user
    // Mock Firebase Auth
    mockitoUtils = MockitoUtils()
    mockitoUtils.chooseCurrentUser(currentProfile.uid, true)
    fakeViewModel =
        HomePageViewModel(
            toDosRepository = todosLocalRepo,
            eventsRepository = eventsLocalRepo,
            profileRepository = profileLocalRepo,
            notificationsRepository = notificationsRepository,
            pointsRepository = pointsRepository,
            authProvider = { mockitoUtils.mockAuth })
    composeRule.setContent {
      HomePageScreen(
          homePageViewModel = fakeViewModel,
          homePageScreenActions = HomePageScreenActions(),
          coordinator = mapCoordinator)
    }

    // Check that the friends section is not displayed
    composeRule.onNodeWithTag(HomePageScreenTestTags.FRIENDS_SECTION).assertIsNotDisplayed()
  }

  /** Verifies that friends avatars are displayed */
  @Test
  fun friendAvatars_areDisplayed_forMultipleFriends() {
    setContentWithGoogle()
    currentProfile.friendUids.forEach { uid ->
      composeRule
          .onNodeWithTag(useUnmergedTree = true, testTag = getFriendProfilePicTestTag(uid))
          .assertIsDisplayed()
    }
  }

  /** Ensures that each friend has a visible status indicator. */
  @Test
  fun friendStatusIndicators_areDisplayed() {
    setContentWithGoogle()
    composeRule.waitForIdle()
    composeRule
        .onNodeWithTag(testTag = getFriendStatusTestTag(friend1.uid), useUnmergedTree = true)
        .assertIsDisplayed()

    composeRule
        .onNodeWithTag(getFriendStatusTestTag(friend2.uid), useUnmergedTree = true)
        .assertIsDisplayed()
  }

  /** Verifies that the empty task list text button is displayed when there are no todos */
  @Test
  fun emptyTaskList_displaysTextButton() {
    runBlocking { todosLocalRepo.deleteTodo(todo1.uid) }
    setContentWithGoogle()

    composeRule
        .onNodeWithTag(
            testTag = HomePageScreenTestTags.EMPTY_TASK_LIST_TEXT_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed()
  }

  /** Verifies that the empty friends message (icon + text) is displayed when user has no friends */
  @Test
  fun emptyFriends_displaysAddFriendsMessage() {
    runBlocking { profileLocalRepo.updateProfile(currentProfile.copy(friendUids = emptyList())) }
    setContentWithGoogle()

    composeRule
        .onNodeWithTag(testTag = HomePageScreenTestTags.ADD_FRIENDS_ICON, useUnmergedTree = true)
        .assertIsDisplayed()
    composeRule
        .onNodeWithTag(HomePageScreenTestTags.ADD_FRIENDS_TEXT, useUnmergedTree = true)
        .assertIsDisplayed()
  }

  /** Verifies that the scrollable friendList displays friends correctly */
  @Test
  fun friendsList_scrollable_displaysAllFriends() {
    // Create a current profile with 5 friends
    val manyFriends =
        (1..5).map { i ->
          Profile(
              uid = "scroll_friend$i",
              name = "Friend $i",
              focusSessionIds = emptyList(),
              participatingEventIds = emptyList(),
              groupIds = emptyList(),
              friendUids = emptyList(),
              status = ProfileStatus.ONLINE)
        }

    runBlocking {
      profileLocalRepo.updateProfile(currentProfile.copy(friendUids = manyFriends.map { it.uid }))
      manyFriends.forEach { profileLocalRepo.addProfile(it) }
    }

    setContentWithGoogle()
    composeRule.waitForIdle()
    // Check first friend is visible
    composeRule
        .onNodeWithTag(getFriendProfilePicTestTag("scroll_friend1"), useUnmergedTree = true)
        .assertIsDisplayed()

    // Scroll LazyColumn to the last friend
    composeRule
        .onNodeWithTag(HomePageScreenTestTags.FRIENDS_LAZY_COLUMN, useUnmergedTree = true)
        .performScrollToNode(hasTestTag(getFriendProfilePicTestTag("scroll_friend5")))

    // Assert last friend is displayed
    composeRule
        .onNodeWithTag(getFriendProfilePicTestTag("scroll_friend5"), useUnmergedTree = true)
        .assertIsDisplayed()
  }

  /** Verifies that the scrollable task list displays all todos correctly */
  @Test
  fun taskList_scrollable_displaysAllTodos() {
    // Create multiple todos to ensure scrolling is required
    val manyTodos =
        (2..6).map { i ->
          ToDo(
              uid = "scroll_todo$i",
              name = "Task $i",
              description = "Description $i",
              dueDate = Timestamp.now(),
              dueTime = null,
              location = null,
              status = ToDoStatus.ONGOING,
              ownerId = currentProfile.uid)
        }

    runBlocking { manyTodos.forEach { todosLocalRepo.addTodo(it) } }

    setContentWithGoogle()
    composeRule.waitForIdle()

    // Check first task is visible
    composeRule
        .onNodeWithTag(getTaskItemTestTag(todo1.uid), useUnmergedTree = true)
        .assertIsDisplayed()

    // Scroll LazyColumn to the last task
    composeRule
        .onNodeWithTag(HomePageScreenTestTags.TASKS_LAZY_COLUMN, useUnmergedTree = true)
        .performScrollToNode(hasTestTag(getTaskItemTestTag("scroll_todo6")))

    // Assert last task is displayed
    composeRule
        .onNodeWithTag(getTaskItemTestTag("scroll_todo6"), useUnmergedTree = true)
        .assertIsDisplayed()
  }
}
