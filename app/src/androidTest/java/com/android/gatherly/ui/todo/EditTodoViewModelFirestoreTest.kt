package com.android.gatherly.ui.todo

import androidx.test.ext.junit.runners.AndroidJUnit4
import com.android.gatherly.model.todo.ToDo
import com.android.gatherly.model.todo.ToDoStatus
import com.android.gatherly.model.todo.ToDosRepository
import com.android.gatherly.utils.FirestoreGatherlyTest
import com.google.firebase.Timestamp
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.withContext
import kotlinx.coroutines.withTimeout
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith

private const val TIMEOUT = 100_000L
private const val DELAY = 100L

// Portions of the code in this file were generated by an LLM.

/**
 * Integration tests for [EditTodoViewModel] using the real Firestore repository (via emulator).
 *
 * These tests verify that valid edits update Firestore correctly, invalid inputs are rejected, and
 * repository errors are surfaced in UI state.
 */
@RunWith(AndroidJUnit4::class)
class EditTodoViewModelFirestoreTest : FirestoreGatherlyTest() {

  private lateinit var viewModel: EditTodoViewModel
  private lateinit var baseTodo: ToDo

  @Before
  override fun setUp() {
    super.setUp()
    viewModel = EditTodoViewModel(repository)

    // Create a base ToDo in Firestore to edit later
    runTest {
      baseTodo =
          ToDo(
              uid = repository.getNewUid(),
              name = "Initial task",
              description = "Original description",
              assigneeName = "John",
              dueDate = Timestamp.now(),
              dueTime = null,
              location = null,
              status = ToDoStatus.ONGOING,
              ownerId = "owner")
      repository.addTodo(baseTodo)
    }
  }

  @Test
  fun loadTodo_withValidId_loadsSuccessfully() = runTest {
    viewModel.loadTodo(baseTodo.uid)

    withContext(Dispatchers.Default.limitedParallelism(1)) {
      withTimeout(TIMEOUT) {
        while (viewModel.uiState.value.title.isEmpty() &&
            viewModel.uiState.value.errorMsg == null) {
          delay(DELAY)
        }
      }
    }

    val state = viewModel.uiState.value
    assertEquals("Initial task", state.title)
    assertEquals("Original description", state.description)
    assertEquals("John", state.assignee)
    assertNull(state.errorMsg)
  }

  @Test
  fun loadTodo_withInvalidId_setsErrorMessage() = runTest {
    viewModel.loadTodo("nonexistent-id")

    withContext(Dispatchers.Default.limitedParallelism(1)) {
      withTimeout(TIMEOUT) {
        while (viewModel.uiState.value.errorMsg == null) {
          delay(DELAY)
        }
      }
    }

    assertTrue(viewModel.uiState.value.errorMsg!!.contains("Failed to load ToDo"))
  }

  @Test
  fun editTodo_withValidFields_updatesRepository() = runTest {
    // Load the current ToDo
    viewModel.loadTodo(baseTodo.uid)
    withContext(Dispatchers.Default.limitedParallelism(1)) {
      withTimeout(TIMEOUT) { while (viewModel.uiState.value.title.isBlank()) delay(DELAY) }
    }

    // Provide valid values for all required fields
    viewModel.onTitleChanged("Updated title")
    viewModel.onDescriptionChanged("Updated description")
    viewModel.onAssigneeChanged("Mary")
    viewModel.onDateChanged("10/10/2025")
    viewModel.onTimeChanged("14:00")
    viewModel.onLocationChanged("Place")

    // Perform the edit
    viewModel.editTodo(baseTodo.uid)

    // Wait for async Firestore write
    withContext(Dispatchers.Default.limitedParallelism(1)) {
      withTimeout(TIMEOUT) {
        var updated: ToDo? = null
        while (updated == null || updated.name != "Updated title") {
          delay(DELAY)
          updated = repository.getTodo(baseTodo.uid)
        }
      }
    }

    val updated = repository.getTodo(baseTodo.uid)
    assertEquals("Updated title", updated.name)
    assertEquals("Updated description", updated.description)
    assertEquals("Mary", updated.assigneeName)
    assertEquals(ToDoStatus.ONGOING, updated.status)
  }

  @Test
  fun editTodo_withInvalidDate_doesNotSave() = runTest {
    viewModel.onTitleChanged("Invalid edit")
    viewModel.onDescriptionChanged("Bad date")
    viewModel.onAssigneeChanged("User")
    viewModel.onDateChanged("15-10-2025") // Wrong format
    viewModel.onTimeChanged("14:00")
    viewModel.onLocationChanged("Place")

    viewModel.editTodo(baseTodo.uid)
    delay(DELAY)

    val state = viewModel.uiState.value
    assertNotNull(state.dueDateError)
    assertTrue(state.dueDateError!!.contains("Invalid format (dd/MM/yyyy)"))
  }

  @Test
  fun editTodo_withEmptyFields_doesNotProceed() = runTest {
    viewModel.onTitleChanged("") // Missing title
    viewModel.onDescriptionChanged("Desc")
    viewModel.onAssigneeChanged("A")
    viewModel.onDateChanged("10/10/2025")
    viewModel.onTimeChanged("14:00")
    viewModel.onLocationChanged("Place")

    viewModel.editTodo(baseTodo.uid)
    delay(DELAY)

    val state = viewModel.uiState.value
    assertEquals("Title cannot be empty", state.titleError)
  }

  @Test
  fun deleteTodo_removesItemFromRepository() = runTest {
    repository.addTodo(
        ToDo(
            uid = "delete-me",
            name = "To delete",
            description = "temporary",
            assigneeName = "Someone",
            dueDate = Timestamp.now(),
            dueTime = null,
            location = null,
            status = ToDoStatus.ONGOING,
            ownerId = "owner"))

    viewModel.deleteToDo("delete-me")
    // Wait deterministically until the repository no longer contains it
    withContext(Dispatchers.Default.limitedParallelism(1)) {
      withTimeout(TIMEOUT) {
        while (repository.getAllTodos().any { it.uid == "delete-me" }) {
          delay(DELAY)
        }
      }
    }

    val all = repository.getAllTodos()
    assertTrue(all.none { it.uid == "delete-me" })
  }

  @Test
  fun deleteTodo_withFailure_setsErrorMsg() = runTest {
    val failingRepo =
        object : ToDosRepository {
          override suspend fun addTodo(toDo: ToDo) = Unit

          override suspend fun getAllTodos() = emptyList<ToDo>()

          override suspend fun getTodo(todoID: String) = baseTodo

          override suspend fun deleteTodo(todoID: String) {
            throw RuntimeException("Simulated delete failure")
          }

          override suspend fun editTodo(todoID: String, newValue: ToDo) = Unit

          override suspend fun getAllEndedTodos() = emptyList<ToDo>()

          override fun getNewUid() = "fake"

          override suspend fun toggleStatus(todoID: String) = Unit
        }

    val viewModel = EditTodoViewModel(failingRepo)
    viewModel.deleteToDo("anything")

    withContext(Dispatchers.Default.limitedParallelism(1)) {
      withTimeout(TIMEOUT) {
        while (viewModel.uiState.value.errorMsg == null) {
          delay(DELAY)
        }
      }
    }

    assertTrue(viewModel.uiState.value.errorMsg!!.contains("Failed to delete ToDo"))
  }
}
