package com.android.gatherly.ui.groups

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import com.android.gatherly.model.group.Group
import com.android.gatherly.model.group.GroupsRepository
import com.android.gatherly.model.group.GroupsRepositoryFirestore
import com.android.gatherly.model.group.GroupsRepositoryProvider
import com.android.gatherly.model.notification.Notification
import com.android.gatherly.model.notification.NotificationType
import com.android.gatherly.model.notification.NotificationsRepository
import com.android.gatherly.model.notification.NotificationsRepositoryProvider
import com.android.gatherly.model.points.PointsRepository
import com.android.gatherly.model.points.PointsRepositoryProvider
import com.android.gatherly.model.profile.Profile
import com.android.gatherly.model.profile.ProfileRepository
import com.android.gatherly.model.profile.ProfileRepositoryFirestore
import com.android.gatherly.model.profile.ProfileRepositoryProvider
import com.android.gatherly.utils.getProfileWithSyncedFriendNotifications
import com.google.firebase.Firebase
import com.google.firebase.Timestamp
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.auth
import com.google.firebase.firestore.firestore
import com.google.firebase.storage.storage
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

// This file is inspired from AddTodoViewModel.kt in this project.
// This file contains code generated by an LLM (Claude.ai).

/**
 * Represents the UI state of the Add Group screen.
 *
 * @param name The entered name
 * @param description The entered description
 * @param nameError String to display if the name is empty
 * @param friendsList The list of the friends to display, filtered with a query if needed
 * @param selectedFriends The list of profiles of the friends that were selected to be added
 * @param isFriendsLoading If the friends are currently being fetched
 * @param friendsError To be displayed if there was an error loading friends
 * @param isSaving If the group is being saved
 * @param saveError To be displayed if the save failed
 * @param saveSuccess Boolean to navigate if the save succeeded
 */
data class AddGroupUiState(
    val name: String = "",
    val description: String = "",
    val nameError: String? = null,
    val friendsList: List<Profile> = emptyList(),
    val selectedFriends: List<Profile> = emptyList(),
    val isFriendsLoading: Boolean = false,
    val friendsError: String? = null,
    val isSaving: Boolean = false,
    val saveError: String? = null,
    val saveSuccess: Boolean = false
)

/**
 * ViewModel responsible for managing the "Add Group" screen.
 *
 * Handles user input updates, field validation, friend selection, and saving Group items to the
 * Firestore repository through [GroupsRepository].
 *
 * @param groupsRepository The repository responsible for persisting Group items.
 * @param profileRepository The repository responsible for fetching user profiles and friends.
 * @param pointsRepository The repository responsible for adding points to users
 * @param notificationsRepository The repository responsible for fetching user notifications
 * @param authProvider The injection for authentication, to be replaced by mocks in tests
 */
class AddGroupViewModel(
    private val groupsRepository: GroupsRepository = GroupsRepositoryProvider.repository,
    private val profileRepository: ProfileRepository = ProfileRepositoryProvider.repository,
    private val pointsRepository: PointsRepository = PointsRepositoryProvider.repository,
    private val notificationsRepository: NotificationsRepository =
        NotificationsRepositoryProvider.repository,
    private val authProvider: () -> FirebaseAuth = { Firebase.auth }
) : ViewModel() {
  /** Private mutable state for Add Group UI */
  private val _uiState = MutableStateFlow(AddGroupUiState())

  /** Public immutable access to the Add Group UI state. */
  val uiState: StateFlow<AddGroupUiState> = _uiState.asStateFlow()

  /** Local copy of all friends */
  private var friendsList: List<Profile> = emptyList()

  init {
    loadFriends()
  }

  /** Clears the error message in the UI state. */
  fun clearErrorMsg() {
    _uiState.value = _uiState.value.copy(saveError = null)
  }

  /** Clears the save success flag in the UI state. */
  fun clearSaveSuccess() {
    _uiState.value = _uiState.value.copy(saveSuccess = false)
  }

  /**
   * Updates the name field and validates that it is not blank.
   *
   * @param newValue The new name entered by the user. If blank, a validation error is set.
   */
  fun onNameChanged(newValue: String) {
    _uiState.value =
        _uiState.value.copy(
            name = newValue, nameError = if (newValue.isBlank()) "Name cannot be empty" else null)
  }

  /**
   * Updates the description field.
   *
   * @param newValue The new description entered by the user.
   */
  fun onDescriptionChanged(newValue: String) {
    _uiState.value = _uiState.value.copy(description = newValue)
  }

  /**
   * Loads the current user's friends list from the repository.
   *
   * Fetches the user's profile and then retrieves each friend's profile to populate the friends
   * list in the UI state.
   */
  private fun loadFriends() {
    viewModelScope.launch {
      _uiState.value = _uiState.value.copy(isFriendsLoading = true, friendsError = null)
      try {
        val currentUserId =
            authProvider().currentUser?.uid ?: throw IllegalStateException("No signed in user")
        val currentProfile =
            getProfileWithSyncedFriendNotifications(
                profileRepository = profileRepository,
                notificationsRepository = notificationsRepository,
                pointsRepository = pointsRepository,
                userId = currentUserId)
                ?: throw NoSuchElementException("Current user profile not found")

        val friendProfiles =
            currentProfile.friendUids.mapNotNull { friendId ->
              try {
                profileRepository.getProfileByUid(friendId)
              } catch (e: Exception) {
                Log.e("AddGroupViewModel", "Failed to fetch friend profile for id=$friendId", e)
                null // Skip friends that can't be fetched
              }
            }

        friendsList = friendProfiles

        _uiState.value = _uiState.value.copy(friendsList = friendProfiles, isFriendsLoading = false)
      } catch (e: Exception) {
        _uiState.value =
            _uiState.value.copy(
                friendsList = emptyList(), friendsError = e.message, isFriendsLoading = false)
      }
    }
  }

  /**
   * Toggles the selection of a friend for the group.
   *
   * @param friend The [Profile] of the friend to toggle selection for.
   */
  fun onFriendToggled(friend: Profile) {
    val currentSelected = _uiState.value.selectedFriends
    val newSelected =
        if (friend in currentSelected) {
          currentSelected.filter { it != friend }
        } else {
          currentSelected + friend
        }
    _uiState.value = _uiState.value.copy(selectedFriends = newSelected)
  }

  /**
   * Attempts to create and save a new [Group] entry to the repository.
   *
   * Performs field validation before saving, and updates the UI state to reflect loading, success,
   * and error states. Selected friends are added as initial members of the group.
   */
  fun saveGroup() {
    val validated =
        _uiState.value.copy(
            nameError = if (_uiState.value.name.isBlank()) "Name cannot be empty" else null)
    _uiState.value = validated

    // Abort if validation failed
    if (_uiState.value.nameError != null) {
      return
    }

    viewModelScope.launch {
      _uiState.value = _uiState.value.copy(isSaving = true, saveError = null)
      try {
        // Create a group
        val gid = groupsRepository.getNewId()

        val group =
            Group(
                gid = gid,
                creatorId = "", // will be filled by Firestore repo
                name = validated.name,
                description = validated.description.ifBlank { null },
                memberIds =
                    validated.selectedFriends.map { it.uid }, // selected friends as initial members
                adminIds = emptyList() // creator will be added by Firestore repo
                )

        groupsRepository.addGroup(group)

        // Add notifications for members
        for (member in uiState.value.selectedFriends) {
          val nid = notificationsRepository.getNewId()

          val notification =
              Notification(
                  id = nid,
                  type = NotificationType.GROUP_ADDED,
                  emissionTime = Timestamp.now(),
                  senderId = authProvider().currentUser?.uid ?: "",
                  relatedEntityId = gid,
                  recipientId = member.uid,
                  wasRead = false)
          notificationsRepository.addNotification(notification)
        }
        _uiState.value = _uiState.value.copy(isSaving = false, saveSuccess = true)
      } catch (e: Exception) {
        _uiState.value = _uiState.value.copy(isSaving = false, saveError = e.message)
      }
    }
  }

  /**
   * Function to filter the friends to display according to a search query
   *
   * @param query the query to filter by
   */
  fun filterFriends(query: String) {
    if (query.isNotBlank()) {
      val filteredList =
          friendsList.filter { profile -> profile.username.contains(query, ignoreCase = true) }

      _uiState.value = _uiState.value.copy(friendsList = filteredList)
    } else {
      _uiState.value = _uiState.value.copy(friendsList = friendsList)
    }
  }

  // The companion object provides a factory method to create instances of AddGroupViewModel. The
  // function was generated by an LLM, using the previous factory implementation in AddGroupScreen.
  /**
   * Factory to create AddGroupViewModel with dependencies.
   *
   * @param groupsRepository The GroupsRepository to use (default: Firestore implementation).
   * @param profileRepository The ProfileRepository to use (default: Firestore implementation).
   * @param authProvider A function that provides the FirebaseAuth instance (default:
   *   Firebase.auth).
   * @return A ViewModelProvider.Factory that creates AddGroupViewModel instances.
   */
  companion object {
    fun provideFactory(
        groupsRepository: GroupsRepository = GroupsRepositoryFirestore(Firebase.firestore),
        profileRepository: ProfileRepository =
            ProfileRepositoryFirestore(Firebase.firestore, Firebase.storage),
        authProvider: () -> FirebaseAuth = { Firebase.auth }
    ): ViewModelProvider.Factory {
      return object : ViewModelProvider.Factory {
        @Suppress("UNCHECKED_CAST")
        override fun <T : ViewModel> create(modelClass: Class<T>): T {
          return AddGroupViewModel(
              groupsRepository = groupsRepository,
              profileRepository = profileRepository,
              authProvider = authProvider)
              as T
        }
      }
    }
  }
}
