package com.android.gatherly.ui.map

import android.content.Context
import android.location.Location as AndroidLocation
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import com.android.gatherly.model.event.Event
import com.android.gatherly.model.event.EventStatus
import com.android.gatherly.model.event.EventsRepository
import com.android.gatherly.model.event.EventsRepositoryFirestore
import com.android.gatherly.model.map.DisplayedMapElement
import com.android.gatherly.model.map.Location
import com.android.gatherly.model.todo.ToDo
import com.android.gatherly.model.todo.ToDoStatus
import com.android.gatherly.model.todo.ToDosRepository
import com.android.gatherly.model.todo.ToDosRepositoryFirestore
import com.android.gatherly.utils.GenericViewModelFactory
import com.android.gatherly.utils.MapCoordinator
import com.android.gatherly.utils.locationFlow
import com.google.android.gms.location.FusedLocationProviderClient
import com.google.android.gms.maps.model.LatLng
import com.google.firebase.Firebase
import com.google.firebase.firestore.firestore
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import kotlinx.coroutines.withTimeoutOrNull

// This file contains code generated by an LLM (Claude.ai, Gemini, GitHub CoPilot).

/**
 * Default location coordinates for EPFL campus.
 *
 * Used as a last-resort fallback when:
 * - there is no last consulted item,
 * - there is no pending navigation request from [MapCoordinator],
 * - and the user's current location cannot be fetched.
 */
val EPFL_LATLNG = LatLng(46.5197, 6.5663)

/**
 * Timeout duration for fetching a first user location update.
 *
 * This prevents the map from being stuck indefinitely if location is disabled, permissions are
 * denied, or the location provider is slow to respond.
 */
private const val LOCATION_FETCH_TIMEOUT_MS = 5_000L

/**
 * UI state exposed by [MapViewModel].
 *
 * Fields:
 * - [itemsList]: the current list of elements shown on the map (either ToDos or Events depending on
 *   [displayEventsPage]).
 * - [selectedItemId]: currently selected item, used by the UI to decide which bottom sheet to show.
 * - [lastConsultedTodoId] and [lastConsultedEventId]: last item opened from the map, used to
 *   re-center the camera when returning to the map.
 * - [cameraPos]: current target for initializing the map camera. When null, UI may display a
 *   loading state until initialization sets it.
 * - [errorMsg]: optional error message if you later decide to propagate repository or location
 *   errors.
 * - [displayEventsPage]: true when the map is in Events mode, false when in ToDos mode.
 * - [currentUserLocation]: latest user location observed from location updates (if enabled).
 */
data class UIState(
    val itemsList: List<DisplayedMapElement> = emptyList(),
    val selectedItemId: String? = null,
    val lastConsultedTodoId: String? = null,
    val lastConsultedEventId: String? = null,
    val cameraPos: LatLng? = null,
    val errorMsg: String? = null,
    val displayEventsPage: Boolean = false,
    val currentUserLocation: LatLng? = null
)

/**
 * Returns ToDos that can be displayed on the map.
 *
 * Filter rules:
 * - Excludes ended ToDos.
 * - Excludes ToDos without a location.
 */
private fun getDrawableTodos(todos: List<ToDo>): List<ToDo> {
  return todos.filter { it.status != ToDoStatus.ENDED && it.location != null }
}

/**
 * Returns Events that can be displayed on the map.
 *
 * Filter rules:
 * - Excludes past Events.
 * - Excludes Events without a location.
 */
private fun getDrawableEvents(events: List<Event>): List<Event> {
  return events.filter { it.status != EventStatus.PAST && it.location != null }
}

/**
 * ViewModel backing [MapScreen].
 *
 * Responsibilities:
 * - Load ToDos and Events, filter them to keep only displayable items, and expose them via
 *   [uiState].
 * - Track the current map mode (ToDos vs Events) and the currently selected item.
 * - Manage map camera initialization target via [UIState.cameraPos] using a priority order:
 *     1) last consulted ToDo
 *     2) pending event id from [MapCoordinator]
 *     3) pending todo id from [MapCoordinator]
 *     4) last consulted Event
 *     5) user's current location (best effort, with timeout)
 *     6) [EPFL_LATLNG] fallback
 * - Optionally observe continuous user location updates and expose them via
 *   [UIState.currentUserLocation].
 *
 * Notes:
 * - [fusedLocationClient] is nullable so tests can run without a real location provider.
 * - Data loading is done in [Dispatchers.IO]. The ViewModel waits for this job before choosing a
 *   camera target in [initialiseCameraPosition].
 */
class MapViewModel(
    private val todosRepository: ToDosRepository = ToDosRepositoryFirestore(Firebase.firestore),
    private val eventsRepository: EventsRepository = EventsRepositoryFirestore(Firebase.firestore),
    private val fusedLocationClient: FusedLocationProviderClient? = null,
    private val coordinator: MapCoordinator
) : ViewModel() {

  private val _uiState = MutableStateFlow(UIState())
  val uiState: StateFlow<UIState> = _uiState.asStateFlow()

  /** Cached ToDo list used for view switching and fast lookup when centering the camera. */
  private var todoList: List<ToDo> = emptyList()

  /** Cached Event list used for view switching and fast lookup when centering the camera. */
  private var eventsList: List<Event> = emptyList()

  /** Job collecting continuous location updates. */
  private var locationJob: Job? = null

  /** Job used to load initial ToDos and Events. */
  private var loadingDataJob: Job? = null

  /**
   * Loads initial ToDos and Events and publishes default UI state.
   *
   * Default behavior:
   * - Start in ToDos mode.
   * - Set [UIState.itemsList] to the filtered ToDo list.
   */
  init {
    loadingDataJob =
        viewModelScope.launch(Dispatchers.IO) {
          val todos = todosRepository.getAllTodos()
          todoList = getDrawableTodos(todos)

          val events = eventsRepository.getAllEvents()
          eventsList = getDrawableEvents(events)

          _uiState.update { it.copy(itemsList = todoList, displayEventsPage = false) }
        }
  }

  /**
   * Starts continuous location updates and updates [UIState.currentUserLocation].
   *
   * If [fusedLocationClient] is null (common in tests), this does nothing.
   *
   * Call [stopLocationUpdates] to cancel the collector when leaving the screen.
   */
  fun startLocationUpdates(context: Context) {
    locationJob?.cancel()
    locationJob =
        viewModelScope.launch {
          fusedLocationClient?.locationFlow(context)?.collect { location: AndroidLocation ->
            val latLng = LatLng(location.latitude, location.longitude)
            _uiState.update { it.copy(currentUserLocation = latLng) }
          }
        }
  }

  /** Stops continuous location updates started by [startLocationUpdates]. */
  fun stopLocationUpdates() {
    locationJob?.cancel()
    locationJob = null
  }

  /** Converts a domain [Location] into a Google Maps [LatLng]. */
  private fun toLatLng(location: Location): LatLng = LatLng(location.latitude, location.longitude)

  /**
   * Initializes the camera target for MapScreen.
   *
   * This suspends until initial data loading is complete to ensure lookups can succeed, then sets
   * [UIState.cameraPos] based on [fetchLocationToCenterOn].
   */
  suspend fun initialiseCameraPosition(context: Context) {
    loadingDataJob?.join()
    val pos = fetchLocationToCenterOn(context)
    _uiState.update { it.copy(cameraPos = pos) }
  }

  /**
   * Marks an item as selected.
   *
   * UI should react by showing the correct bottom sheet for [UIState.selectedItemId].
   */
  fun onSelectedItem(itemId: String) {
    _uiState.update { it.copy(selectedItemId = itemId) }
  }

  /**
   * Clears the current selection.
   *
   * UI should react by dismissing any open bottom sheet.
   */
  fun clearSelection() {
    _uiState.update { it.copy(selectedItemId = null) }
  }

  /**
   * Marks an item as "consulted" (opened via the bottom sheet action).
   *
   * Behavior:
   * - Sets last consulted id for the active page (ToDo or Event).
   * - Clears the last consulted id for the other page.
   * - Sets [UIState.cameraPos] to null to force MapScreen to re-run initialization and re-center
   *   next time.
   */
  fun onItemConsulted(itemId: String) {
    _uiState.update { state ->
      if (state.displayEventsPage) {
        state.copy(lastConsultedEventId = itemId, lastConsultedTodoId = null, cameraPos = null)
      } else {
        state.copy(lastConsultedTodoId = itemId, lastConsultedEventId = null, cameraPos = null)
      }
    }
  }

  /**
   * Called when navigating away from the map.
   *
   * By setting [UIState.cameraPos] to null, MapScreen can display a loading state and re-initialize
   * the camera when returning (depending on your UI logic).
   */
  fun onNavigationToDifferentScreen() {
    _uiState.update { it.copy(cameraPos = null) }
  }

  /**
   * Toggles between ToDo mode and Event mode.
   *
   * Updates:
   * - [UIState.displayEventsPage]
   * - [UIState.itemsList] to the corresponding cached list
   */
  fun changeView() {
    _uiState.update { state ->
      if (state.displayEventsPage) {
        state.copy(itemsList = todoList, displayEventsPage = false)
      } else {
        state.copy(itemsList = eventsList, displayEventsPage = true)
      }
    }
  }

  /**
   * Computes the best camera target for MapScreen according to priority.
   *
   * Priority order:
   * 1) last consulted ToDo (from [UIState.lastConsultedTodoId])
   * 2) pending Event id provided by [MapCoordinator] (one-shot)
   * 3) pending ToDo id provided by [MapCoordinator] (one-shot)
   * 4) last consulted Event (from [UIState.lastConsultedEventId])
   * 5) user's current location (best effort, first emission only, with timeout)
   * 6) [EPFL_LATLNG] fallback
   *
   * Side effects:
   * - When a coordinator id is consumed, [MapCoordinator.markConsumed] is called.
   * - When centering on a coordinator-provided id, this also updates [UIState.displayEventsPage]
   *   and [UIState.itemsList] to the appropriate mode so the UI matches the centered content.
   */
  suspend fun fetchLocationToCenterOn(context: Context): LatLng {
    _uiState.value.lastConsultedTodoId
        ?.let { lastTodoId -> todoList.find { it.uid == lastTodoId }?.location }
        ?.let {
          return toLatLng(it)
        }

    coordinator.getUnconsumedEventId()?.let { eventId ->
      eventsList
          .find { it.id == eventId }
          ?.location
          ?.let { location ->
            coordinator.markConsumed()
            _uiState.update { it.copy(displayEventsPage = true, itemsList = eventsList) }
            return toLatLng(location)
          }
    }

    coordinator.getUnconsumedTodoId()?.let { todoId ->
      todoList
          .find { it.uid == todoId }
          ?.location
          ?.let { location ->
            coordinator.markConsumed()
            _uiState.update { it.copy(displayEventsPage = false, itemsList = todoList) }
            return toLatLng(location)
          }
    }

    _uiState.value.lastConsultedEventId
        ?.let { lastEventId -> eventsList.find { it.id == lastEventId }?.location }
        ?.let {
          return toLatLng(it)
        }

    val currentLocation =
        try {
          withTimeoutOrNull(LOCATION_FETCH_TIMEOUT_MS) {
            fusedLocationClient?.locationFlow(context)?.first()
          }
        } catch (_: Exception) {
          null
        }

    if (currentLocation != null) {
      return LatLng(currentLocation.latitude, currentLocation.longitude)
    }

    return EPFL_LATLNG
  }

  companion object {
    /**
     * Provides a [ViewModelProvider.Factory] for constructing [MapViewModel] with dependencies.
     *
     * Useful for:
     * - production wiring through a ViewModel factory
     * - tests that want to inject fake repositories or a fake location provider
     */
    fun provideFactory(
        todosRepository: ToDosRepository = ToDosRepositoryFirestore(Firebase.firestore),
        eventsRepository: EventsRepository = EventsRepositoryFirestore(Firebase.firestore),
        fusedLocationClient: FusedLocationProviderClient? = null,
        coordinator: MapCoordinator
    ): ViewModelProvider.Factory {
      return GenericViewModelFactory {
        MapViewModel(todosRepository, eventsRepository, fusedLocationClient, coordinator)
      }
    }
  }
}
