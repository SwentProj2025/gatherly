package com.android.gatherly.ui.map

import android.content.Context
import android.location.Location as AndroidLocation
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import com.android.gatherly.model.event.Event
import com.android.gatherly.model.event.EventStatus
import com.android.gatherly.model.event.EventsRepository
import com.android.gatherly.model.event.EventsRepositoryFirestore
import com.android.gatherly.model.map.DisplayedMapElement
import com.android.gatherly.model.map.Location
import com.android.gatherly.model.todo.ToDo
import com.android.gatherly.model.todo.ToDoStatus
import com.android.gatherly.model.todo.ToDosRepository
import com.android.gatherly.model.todo.ToDosRepositoryFirestore
import com.android.gatherly.utils.GenericViewModelFactory
import com.android.gatherly.utils.MapCoordinator
import com.android.gatherly.utils.locationFlow
import com.google.android.gms.location.FusedLocationProviderClient
import com.google.android.gms.maps.model.LatLng
import com.google.firebase.Firebase
import com.google.firebase.firestore.firestore
import kotlinx.coroutines.Job
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import kotlinx.coroutines.withTimeoutOrNull

// This file contains code generated by an LLM (Claude.ai, Gemini, GitHub CoPilot).

/** Default location coordinates for EPFL campus. */
val EPFL_LATLNG = LatLng(46.519, 6.5668)

/**
 * Timeout duration for fetching a first user location update.
 *
 * This prevents the map from being stuck indefinitely if location is disabled, permissions are
 * denied, or the location provider is slow to respond.
 */
private const val LOCATION_FETCH_TIMEOUT_MS = 5_000L

/**
 * UI state exposed by [MapViewModel].
 *
 * Fields:
 * - [itemsList]: the current list of elements shown on the map (either ToDos or Events depending on
 *   [displayEventsPage]).
 * - [selectedItemId]: currently selected item, used by the UI to decide which bottom sheet to show.
 * - [lastConsultedTodoId] and [lastConsultedEventId]: last item opened from the map, used to
 *   re-center the camera when returning to the map.
 * - [cameraPos]: current target for initializing the map camera. When null, UI may display a
 *   loading state until initialization sets it.
 * - [errorMsg]: optional error message if you later decide to propagate repository or location
 *   errors.
 * - [displayEventsPage]: true when the map is in Events mode, false when in ToDos mode.
 * - [currentUserLocation]: latest user location observed from location updates (if enabled).
 *
 * @param itemsList The list of elements currently displayed on the map.
 * @param selectedItemId The id of the currently selected element, if any.
 * @param lastConsultedTodoId The id of the last consulted ToDo, if any.
 * @param lastConsultedEventId The id of the last consulted Event, if any.
 * @param cameraPos The current camera target for map initialization, or null if not computed yet.
 * @param errorMsg Optional error message if you choose to propagate errors to the UI.
 * @param displayEventsPage True when the map is showing Events, false when showing ToDos.
 * @param currentUserLocation The most recent user location observed from location updates, if any.
 */
data class UIState(
    val itemsList: List<DisplayedMapElement> = emptyList(),
    val selectedItemId: String? = null,
    val lastConsultedTodoId: String? = null,
    val lastConsultedEventId: String? = null,
    val cameraPos: LatLng? = null,
    val errorMsg: String? = null,
    val displayEventsPage: Boolean = false,
    val currentUserLocation: LatLng? = null
)

/**
 * Returns ToDos that can be displayed on the map.
 *
 * Filter rules:
 * - Excludes ended ToDos.
 * - Excludes ToDos without a location.
 *
 * @param todos All ToDos retrieved from the repository.
 * @return A filtered list containing only ToDos that can be displayed on the map.
 */
private fun getDrawableTodos(todos: List<ToDo>): List<ToDo> {
  return todos.filter { it.status != ToDoStatus.ENDED && it.location != null }
}

/**
 * Returns Events that can be displayed on the map.
 *
 * Filter rules:
 * - Excludes past Events.
 * - Excludes Events without a location.
 *
 * @param events All Events retrieved from the repository.
 * @return A filtered list containing only Events that can be displayed on the map.
 */
private fun getDrawableEvents(events: List<Event>): List<Event> {
  return events.filter { it.status != EventStatus.PAST && it.location != null }
}

/**
 * ViewModel backing [MapScreen].
 *
 * Responsibilities:
 * - Load ToDos and Events, filter them to keep only displayable items, and expose them via
 *   [uiState].
 * - Track the current map mode (ToDos vs Events) and the currently selected item.
 * - Manage map camera initialization target via [UIState.cameraPos] using a priority order:
 *     1) last consulted ToDo
 *     2) pending event id from [MapCoordinator]
 *     3) pending todo id from [MapCoordinator]
 *     4) last consulted Event
 *     5) user's current location (best effort, with timeout)
 *     6) [EPFL_LATLNG] fallback
 * - Optionally observe continuous user location updates and expose them via
 *   [UIState.currentUserLocation].
 *
 * @param todosRepository Repository used to fetch ToDos (default: Firestore implementation).
 * @param eventsRepository Repository used to fetch Events (default: Firestore implementation).
 * @param fusedLocationClient Location provider used to collect location updates (nullable for
 *   tests).
 * @param coordinator Coordinator used to pass one-shot navigation requests to the map (required).
 */
class MapViewModel(
    private val todosRepository: ToDosRepository = ToDosRepositoryFirestore(Firebase.firestore),
    private val eventsRepository: EventsRepository = EventsRepositoryFirestore(Firebase.firestore),
    private val fusedLocationClient: FusedLocationProviderClient? = null,
    private val coordinator: MapCoordinator
) : ViewModel() {

  private val _uiState = MutableStateFlow(UIState())

  /**
   * Public, read-only UI state stream.
   *
   * @return A [StateFlow] of [UIState] reflecting the current map screen state.
   */
  val uiState: StateFlow<UIState> = _uiState.asStateFlow()

  /** Cached ToDo list used for view switching and fast lookup when centering the camera. */
  private var todoList: List<ToDo> = emptyList()

  /** Cached Event list used for view switching and fast lookup when centering the camera. */
  private var eventsList: List<Event> = emptyList()

  /** Job collecting continuous location updates. */
  private var locationJob: Job? = null

  /** Job used to load initial ToDos and Events. */
  private var loadingDataJob: Job? = null

  /** Loads initial ToDos and Events and publishes default UI state. */
  init {
    loadingDataJob =
        viewModelScope.launch {
          val todos = todosRepository.getAllTodos()
          todoList = getDrawableTodos(todos)

          val events = eventsRepository.getAllEvents()
          eventsList = getDrawableEvents(events)

          _uiState.update { it.copy(itemsList = todoList, displayEventsPage = false) }
        }
  }

  /**
   * Starts continuous location updates and updates [UIState.currentUserLocation].
   *
   * @param context Android context used by the underlying location flow.
   */
  fun startLocationUpdates(context: Context) {
    locationJob?.cancel()
    locationJob =
        viewModelScope.launch {
          fusedLocationClient?.locationFlow(context)?.collect { location: AndroidLocation ->
            val latLng = LatLng(location.latitude, location.longitude)
            _uiState.update { it.copy(currentUserLocation = latLng) }
          }
        }
  }

  /** Stops continuous location updates started by [startLocationUpdates]. */
  fun stopLocationUpdates() {
    locationJob?.cancel()
    locationJob = null
  }

  /**
   * Converts a domain [Location] into a Google Maps [LatLng].
   *
   * @param location A domain location containing latitude and longitude.
   * @return The equivalent [LatLng].
   */
  private fun toLatLng(location: Location): LatLng = LatLng(location.latitude, location.longitude)

  /**
   * Initializes the camera target for MapScreen.
   *
   * @param context Android context used to fetch the current user location if needed.
   */
  fun initialiseCameraPosition(context: Context) {
    viewModelScope.launch {
      loadingDataJob?.join()
      val pos = fetchLocationToCenterOn(context)
      _uiState.update { it.copy(cameraPos = pos) }
    }
  }

  /**
   * Marks an item as selected.
   *
   * UI should react by showing the correct bottom sheet for [UIState.selectedItemId].
   *
   * @param itemId The id of the selected item (ToDo uid or Event id).
   */
  fun onSelectedItem(itemId: String) {
    _uiState.update { it.copy(selectedItemId = itemId) }
  }

  /**
   * Clears the current selection.
   *
   * UI should react by dismissing any open bottom sheet.
   */
  fun clearSelection() {
    _uiState.update { it.copy(selectedItemId = null) }
  }

  /**
   * Marks an item as "consulted" (opened via the bottom sheet action).
   *
   * @param itemId The id of the consulted item (ToDo uid or Event id).
   */
  fun onItemConsulted(itemId: String) {
    _uiState.update { state ->
      if (state.displayEventsPage) {
        state.copy(lastConsultedEventId = itemId, lastConsultedTodoId = null, cameraPos = null)
      } else {
        state.copy(lastConsultedTodoId = itemId, lastConsultedEventId = null, cameraPos = null)
      }
    }
  }

  /** Called when navigating away from the map. */
  fun onNavigationToDifferentScreen() {
    _uiState.update { it.copy(cameraPos = null) }
  }

  /** Toggles between ToDo mode and Event mode. */
  fun changeView() {
    _uiState.update { state ->
      if (state.displayEventsPage) {
        state.copy(itemsList = todoList, displayEventsPage = false)
      } else {
        state.copy(itemsList = eventsList, displayEventsPage = true)
      }
    }
  }

  /**
   * Computes the best camera target for MapScreen according to priority.
   *
   * Priority order:
   * 1) last consulted ToDo (from [UIState.lastConsultedTodoId])
   * 2) pending Event id provided by [MapCoordinator] (one-shot)
   * 3) pending ToDo id provided by [MapCoordinator] (one-shot)
   * 4) last consulted Event (from [UIState.lastConsultedEventId])
   * 5) user's current location (best effort, first emission only, with timeout)
   * 6) [EPFL_LATLNG] fallback
   *
   * @param context Android context used to fetch the current user location if needed.
   * @return The [LatLng] that should be used as the camera target.
   */
  private suspend fun fetchLocationToCenterOn(context: Context): LatLng {
    loadingDataJob?.join()

    _uiState.value.lastConsultedTodoId
        ?.let { lastTodoId -> todoList.find { it.uid == lastTodoId }?.location }
        ?.let {
          return toLatLng(it)
        }

    coordinator.getUnconsumedEventId()?.let { eventId ->
      eventsList
          .find { it.id == eventId }
          ?.location
          ?.let { location ->
            coordinator.markConsumed()
            _uiState.update { it.copy(displayEventsPage = true, itemsList = eventsList) }
            return toLatLng(location)
          }
    }

    coordinator.getUnconsumedTodoId()?.let { todoId ->
      todoList
          .find { it.uid == todoId }
          ?.location
          ?.let { location ->
            coordinator.markConsumed()
            _uiState.update { it.copy(displayEventsPage = false, itemsList = todoList) }
            return toLatLng(location)
          }
    }

    _uiState.value.lastConsultedEventId
        ?.let { lastEventId -> eventsList.find { it.id == lastEventId }?.location }
        ?.let {
          return toLatLng(it)
        }

    val currentLocation =
        try {
          withTimeoutOrNull(LOCATION_FETCH_TIMEOUT_MS) {
            fusedLocationClient?.locationFlow(context)?.first()
          }
        } catch (_: Exception) {
          null
        }

    if (currentLocation != null) {
      return LatLng(currentLocation.latitude, currentLocation.longitude)
    }

    return EPFL_LATLNG
  }

  companion object {
    /**
     * Provides a [ViewModelProvider.Factory] for constructing [MapViewModel] with dependencies.
     *
     * @param todosRepository Repository used to fetch ToDos (default: Firestore implementation).
     * @param eventsRepository Repository used to fetch Events (default: Firestore implementation).
     * @param fusedLocationClient Location provider used to collect location updates (nullable for
     *   tests).
     * @param coordinator Coordinator used to pass one-shot navigation requests to the map
     *   (required).
     * @return A [ViewModelProvider.Factory] creating a [MapViewModel] with the provided
     *   dependencies.
     */
    fun provideFactory(
        todosRepository: ToDosRepository = ToDosRepositoryFirestore(Firebase.firestore),
        eventsRepository: EventsRepository = EventsRepositoryFirestore(Firebase.firestore),
        fusedLocationClient: FusedLocationProviderClient? = null,
        coordinator: MapCoordinator
    ): ViewModelProvider.Factory {
      return GenericViewModelFactory {
        MapViewModel(todosRepository, eventsRepository, fusedLocationClient, coordinator)
      }
    }
  }
}
