package com.android.gatherly.ui.map

import android.content.Context
import android.location.Location as AndroidLocation
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import com.android.gatherly.model.event.Event
import com.android.gatherly.model.event.EventStatus
import com.android.gatherly.model.event.EventsRepository
import com.android.gatherly.model.event.EventsRepositoryFirestore
import com.android.gatherly.model.map.DisplayedMapElement
import com.android.gatherly.model.map.Location
import com.android.gatherly.model.todo.ToDo
import com.android.gatherly.model.todo.ToDoStatus
import com.android.gatherly.model.todo.ToDosRepository
import com.android.gatherly.model.todo.ToDosRepositoryFirestore
import com.android.gatherly.utils.GenericViewModelFactory
import com.android.gatherly.utils.MapCoordinator
import com.android.gatherly.utils.locationFlow
import com.google.android.gms.location.FusedLocationProviderClient
import com.google.android.gms.maps.model.LatLng
import com.google.firebase.Firebase
import com.google.firebase.firestore.firestore
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import kotlinx.coroutines.withTimeoutOrNull

// This file contains code generated by an LLM (Claude.ai, Gemini, GitHub CoPilot).

/** Default location coordinates for EPFL campus. */
val EPFL_LATLNG = LatLng(46.5197, 6.5663)

/** Timeout duration for fetching user location. */
private const val LOCATION_FETCH_TIMEOUT_MS = 5_000L

data class UIState(
    val itemsList: List<DisplayedMapElement> = emptyList(),
    val selectedItemId: String? = null,
    val lastConsultedTodoId: String? = null,
    val lastConsultedEventId: String? = null,
    val cameraPos: LatLng? = null,
    val errorMsg: String? = null,
    val displayEventsPage: Boolean = false,
    val currentUserLocation: LatLng? = null
)

private fun getDrawableTodos(todos: List<ToDo>): List<ToDo> {
  return todos.filter { it.status != ToDoStatus.ENDED && it.location != null }
}

private fun getDrawableEvents(events: List<Event>): List<Event> {
  return events.filter { it.status != EventStatus.PAST && it.location != null }
}

class MapViewModel(
    private val todosRepository: ToDosRepository = ToDosRepositoryFirestore(Firebase.firestore),
    private val eventsRepository: EventsRepository = EventsRepositoryFirestore(Firebase.firestore),
    private val fusedLocationClient: FusedLocationProviderClient? = null,
    private val coordinator: MapCoordinator
) : ViewModel() {

  private val _uiState = MutableStateFlow(UIState())
  val uiState: StateFlow<UIState> = _uiState.asStateFlow()

  private var todoList: List<ToDo> = emptyList()
  private var eventsList: List<Event> = emptyList()

  private var locationJob: Job? = null
  private var loadingDataJob: Job? = null

  init {
    loadingDataJob =
        viewModelScope.launch(Dispatchers.IO) {
          val todos = todosRepository.getAllTodos()
          todoList = getDrawableTodos(todos)

          val events = eventsRepository.getAllEvents()
          eventsList = getDrawableEvents(events)

          _uiState.update { it.copy(itemsList = todoList, displayEventsPage = false) }
        }
  }

  fun startLocationUpdates(context: Context) {
    locationJob?.cancel()
    locationJob =
        viewModelScope.launch {
          fusedLocationClient?.locationFlow(context)?.collect { location: AndroidLocation ->
            val latLng = LatLng(location.latitude, location.longitude)
            _uiState.update { it.copy(currentUserLocation = latLng) }
          }
        }
  }

  fun stopLocationUpdates() {
    locationJob?.cancel()
    locationJob = null
  }

  private fun toLatLng(location: Location): LatLng = LatLng(location.latitude, location.longitude)

  suspend fun initialiseCameraPosition(context: Context) {
    loadingDataJob?.join()
    val pos = fetchLocationToCenterOn(context)
    _uiState.update { it.copy(cameraPos = pos) }
  }

  fun onSelectedItem(itemId: String) {
    _uiState.update { it.copy(selectedItemId = itemId) }
  }

  fun clearSelection() {
    _uiState.update { it.copy(selectedItemId = null) }
  }

  fun onItemConsulted(itemId: String) {
    _uiState.update { state ->
      if (state.displayEventsPage) {
        state.copy(lastConsultedEventId = itemId, lastConsultedTodoId = null, cameraPos = null)
      } else {
        state.copy(lastConsultedTodoId = itemId, lastConsultedEventId = null, cameraPos = null)
      }
    }
  }

  fun onNavigationToDifferentScreen() {
    _uiState.update { it.copy(cameraPos = null) }
  }

  fun changeView() {
    _uiState.update { state ->
      if (state.displayEventsPage) {
        state.copy(itemsList = todoList, displayEventsPage = false)
      } else {
        state.copy(itemsList = eventsList, displayEventsPage = true)
      }
    }
  }

  suspend fun fetchLocationToCenterOn(context: Context): LatLng {
    _uiState.value.lastConsultedTodoId
        ?.let { lastTodoId -> todoList.find { it.uid == lastTodoId }?.location }
        ?.let {
          return toLatLng(it)
        }

    coordinator.getUnconsumedEventId()?.let { eventId ->
      eventsList
          .find { it.id == eventId }
          ?.location
          ?.let { location ->
            coordinator.markConsumed()
            _uiState.update { it.copy(displayEventsPage = true, itemsList = eventsList) }
            return toLatLng(location)
          }
    }

    coordinator.getUnconsumedTodoId()?.let { todoId ->
      todoList
          .find { it.uid == todoId }
          ?.location
          ?.let { location ->
            coordinator.markConsumed()
            _uiState.update { it.copy(displayEventsPage = false, itemsList = todoList) }
            return toLatLng(location)
          }
    }

    _uiState.value.lastConsultedEventId
        ?.let { lastEventId -> eventsList.find { it.id == lastEventId }?.location }
        ?.let {
          return toLatLng(it)
        }

    val currentLocation =
        try {
          withTimeoutOrNull(LOCATION_FETCH_TIMEOUT_MS) {
            fusedLocationClient?.locationFlow(context)?.first()
          }
        } catch (_: Exception) {
          null
        }

    if (currentLocation != null) {
      return LatLng(currentLocation.latitude, currentLocation.longitude)
    }

    return EPFL_LATLNG
  }

  companion object {
    fun provideFactory(
        todosRepository: ToDosRepository = ToDosRepositoryFirestore(Firebase.firestore),
        eventsRepository: EventsRepository = EventsRepositoryFirestore(Firebase.firestore),
        fusedLocationClient: FusedLocationProviderClient? = null,
        coordinator: MapCoordinator
    ): ViewModelProvider.Factory {
      return GenericViewModelFactory {
        MapViewModel(todosRepository, eventsRepository, fusedLocationClient, coordinator)
      }
    }
  }
}
