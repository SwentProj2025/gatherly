package com.android.gatherly.ui.groups

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import com.android.gatherly.model.group.Group
import com.android.gatherly.model.group.GroupsRepository
import com.android.gatherly.model.group.GroupsRepositoryFirestore
import com.android.gatherly.model.notification.NotificationsRepository
import com.android.gatherly.model.notification.NotificationsRepositoryProvider
import com.android.gatherly.model.points.PointsRepository
import com.android.gatherly.model.points.PointsRepositoryProvider
import com.android.gatherly.model.profile.Profile
import com.android.gatherly.model.profile.ProfileRepository
import com.android.gatherly.model.profile.ProfileRepositoryFirestore
import com.android.gatherly.utils.getProfileWithSyncedNotifications
import com.google.firebase.Firebase
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.auth
import com.google.firebase.firestore.firestore
import com.google.firebase.storage.storage
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

// This file was inspired by AddTodoViewModel.kt in this project.
// This file contains code generated by an LLM (Claude.ai).

/**
 * Represents the UI state of the Edit Group screen.
 *
 * @param groupId The id of the group that is loaded
 * @param name The current name of the group
 * @param description The current group description
 * @param nameError The string to display if the name is blank
 * @param currentMemberProfiles The list of profiles of members who are currently group members
 * @param adminIds The list of ids of users who are admin
 * @param friendsList The complete list of the user's friends
 * @param availableFriendsToAdd List of friends that can still be added
 * @param selectedNewFriendIds The list of ids of friends who have been selected to be added
 * @param membersToRemove The list of ids of friends who have been selected to be removed
 * @param currentUserId The id of the current user
 * @param creatorId The id of the group creator
 * @param isLoading If the screen is currently loading
 * @param loadError If there was an error while loading the screen
 * @param isSaving If the group is being saved
 * @param saveError If there was an error while saving the group
 * @param saveSuccess If the group was successfully saved, navigate back to overview
 * @param friendsSearchQuery The search query by which to filter shown friends
 * @param filteredAvailableFriends The friends to add that meet the query filter
 * @param membersForList The current members of the group
 */
data class EditGroupUiState(
    val groupId: String = "",
    val name: String = "",
    val description: String = "",
    val nameError: String? = null,
    val currentMemberProfiles: List<Profile> = emptyList(),
    val adminIds: List<String> = emptyList(),
    val friendsList: List<Profile> = emptyList(),
    val availableFriendsToAdd: List<Profile> = emptyList(),
    val selectedNewFriendIds: List<String> = emptyList(),
    val membersToRemove: List<String> = emptyList(),
    val currentUserId: String = "",
    val creatorId: String = "",
    val isLoading: Boolean = true,
    val loadError: String? = null,
    val isSaving: Boolean = false,
    val saveError: String? = null,
    val saveSuccess: Boolean = false,
    val friendsSearchQuery: String = "",
    val filteredAvailableFriends: List<Profile> = emptyList(),
    val membersForList: List<Profile> = emptyList(),
)

/**
 * ViewModel responsible for managing the "Edit Group" screen.
 *
 * Handles loading an existing group, managing member additions/removals, admin promotion/demotion,
 * field validation, and saving updates to the Firestore repository through [GroupsRepository].
 *
 * @param groupsRepository The repository responsible for persisting Group items.
 * @param profileRepository The repository responsible for fetching user profiles and friends.
 * @param pointsRepository The repository responsible for updating user points history
 * @param notificationsRepository The repository responsible for fetching notifications repository
 * @param authProvider Injection used to have mock auth in tests
 */
class EditGroupViewModel(
    private val groupsRepository: GroupsRepository = GroupsRepositoryFirestore(Firebase.firestore),
    private val profileRepository: ProfileRepository =
        ProfileRepositoryFirestore(Firebase.firestore, Firebase.storage),
    private val pointsRepository: PointsRepository = PointsRepositoryProvider.repository,
    private val notificationsRepository: NotificationsRepository =
        NotificationsRepositoryProvider.repository,
    private val authProvider: () -> FirebaseAuth = { Firebase.auth }
) : ViewModel() {
  /** Private mutable state for Edit Group UI */
  private val _uiState = MutableStateFlow(EditGroupUiState())

  /** Public immutable access to the Edit Group UI state. */
  val uiState: StateFlow<EditGroupUiState> = _uiState.asStateFlow()

  /** Clears the error message in the UI state. */
  fun clearErrorMsg() {
    _uiState.value = _uiState.value.copy(saveError = null, loadError = null)
  }

  /** Clears the save success flag in the UI state. */
  fun clearSaveSuccess() {
    _uiState.value = _uiState.value.copy(saveSuccess = false)
  }

  /**
   * Loads the group with the specified ID and initializes the UI state.
   *
   * Fetches the group data, loads current member profiles, loads the user's friends list, and
   * calculates which friends can be added to the group.
   *
   * @param groupId The ID of the group to edit.
   */
  fun loadGroup(groupId: String) {
    viewModelScope.launch {
      _uiState.value = _uiState.value.copy(isLoading = true, loadError = null)
      try {
        val group = groupsRepository.getGroup(groupId)
        val currentUserId = authProvider().currentUser?.uid

        _uiState.value =
            _uiState.value.copy(
                groupId = group.gid,
                name = group.name,
                description = group.description ?: "",
                adminIds = group.adminIds,
                creatorId = group.creatorId,
                currentUserId = currentUserId.orEmpty())

        loadMemberProfiles(group.memberIds)
        loadFriends(group.memberIds)

        _uiState.value = _uiState.value.copy(isLoading = false)
      } catch (e: Exception) {
        _uiState.value = _uiState.value.copy(isLoading = false, loadError = e.message)
      }
    }
  }

  /**
   * Loads profiles for current group members.
   *
   * @param memberIds List of user IDs who are current members of the group.
   */
  private suspend fun loadMemberProfiles(memberIds: List<String>) {
    try {
      val memberProfiles =
          memberIds.mapNotNull { memberId ->
            try {
              profileRepository.getProfileByUid(memberId)
            } catch (e: Exception) {
              Log.e("EditGroupViewModel", "Failed to fetch profile for $memberId", e)
              null // Skip members that can't be fetched
            }
          }
      updateMembersForList(memberProfiles)
    } catch (e: Exception) {
      // 'Silently' fail - member profiles are not critical for editing
      Log.e("EditGroupViewModel", "Failed to update member profiles UI state", e)
    }
  }

  /** Updates both currentMemberProfiles and membersForList according to current user role. */
  private fun updateMembersForList(memberProfiles: List<Profile>) {
    val state = _uiState.value
    val currentUserId = state.currentUserId
    val creatorId = state.creatorId

    val membersForList =
        if (currentUserId.isNotBlank() && currentUserId == creatorId) {
          // Owner does not see themselves in the editable members list
          memberProfiles.filter { it.uid != currentUserId }
        } else {
          memberProfiles
        }

    _uiState.value =
        state.copy(currentMemberProfiles = memberProfiles, membersForList = membersForList)
  }

  /**
   * Loads the current user's friends list and calculates which friends are available to add.
   *
   * Friends who are already members of the group are excluded from the available list.
   *
   * @param currentMemberIds List of user IDs who are current members of the group.
   */
  private suspend fun loadFriends(currentMemberIds: List<String>) {
    try {
      val currentUserId =
          authProvider().currentUser?.uid ?: throw IllegalStateException("No signed in user")
      val currentProfile =
          getProfileWithSyncedNotifications(
              profileRepository = profileRepository,
              notificationsRepository = notificationsRepository,
              pointsRepository = pointsRepository,
              userId = currentUserId)
              ?: throw NoSuchElementException("Current user profile not found")

      val friendProfiles =
          currentProfile.friendUids.mapNotNull { friendId ->
            try {
              profileRepository.getProfileByUid(friendId)
            } catch (e: Exception) {
              Log.e("EditGroupViewModel", "Failed to fetch profile for friend $friendId", e)
              null // Skip friends that can't be fetched
            }
          }
      val currentMemberIdSet = currentMemberIds.toSet()

      // Friends who are not already members
      val availableFriends = friendProfiles.filter { it.uid !in currentMemberIdSet }

      val searchQuery = _uiState.value.friendsSearchQuery
      val filtered =
          if (searchQuery.isBlank()) {
            availableFriends
          } else {
            availableFriends.filter { it.username.contains(searchQuery, ignoreCase = true) }
          }

      _uiState.value =
          _uiState.value.copy(
              friendsList = friendProfiles,
              availableFriendsToAdd = availableFriends,
              filteredAvailableFriends = filtered)
    } catch (e: Exception) {
      Log.e("EditGroupViewModel", "Failed to load friends list", e)
      // 'Silently' fail - friends list is not critical for basic editing
      _uiState.value =
          _uiState.value.copy(friendsList = emptyList(), availableFriendsToAdd = emptyList())
    }
  }

  /**
   * Updates the name field and validates that it is not blank.
   *
   * @param newValue The new name entered by the user. If blank, a validation error is set.
   */
  fun onNameChanged(newValue: String) {
    _uiState.value =
        _uiState.value.copy(
            name = newValue, nameError = if (newValue.isBlank()) "Name cannot be empty" else null)
  }

  /**
   * Updates the description field.
   *
   * @param newValue The new description entered by the user.
   */
  fun onDescriptionChanged(newValue: String) {
    _uiState.value = _uiState.value.copy(description = newValue)
  }

  /**
   * Toggles the selection of a friend to add to the group.
   *
   * @param friendId The ID of the friend to toggle selection for.
   */
  fun onNewFriendToggled(friendId: String) {
    val currentSelected = _uiState.value.selectedNewFriendIds
    val newSelected =
        if (friendId in currentSelected) {
          currentSelected - friendId
        } else {
          currentSelected + friendId
        }
    _uiState.value = _uiState.value.copy(selectedNewFriendIds = newSelected)
  }

  /**
   * Marks a member for removal from the group.
   *
   * The member will be removed when [saveGroup] is called. If the member is already marked for
   * removal, this call unmarks them.
   *
   * @param memberId The ID of the member to toggle removal for.
   */
  fun onToggleRemoveMember(memberId: String) {
    val currentToRemove = _uiState.value.membersToRemove
    val newToRemove =
        if (memberId in currentToRemove) {
          currentToRemove - memberId
        } else {
          currentToRemove + memberId
        }
    _uiState.value = _uiState.value.copy(membersToRemove = newToRemove)
  }

  /**
   * Toggles the admin status of a group member.
   *
   * If the member is currently an admin, they will be demoted. If they are not an admin, they will
   * be promoted.
   *
   * @param memberId The ID of the member whose admin status to toggle.
   */
  fun onToggleAdmin(memberId: String) {
    val currentAdmins = _uiState.value.adminIds
    val newAdmins =
        if (memberId in currentAdmins) {
          currentAdmins - memberId
        } else {
          currentAdmins + memberId
        }
    _uiState.value = _uiState.value.copy(adminIds = newAdmins)
  }

  /**
   * Attempts to save all modifications to the group.
   *
   * Performs field validation before saving, calculates the final member and admin lists, and
   * updates the group in the repository. Updates the UI state to reflect loading, success, and
   * error states.
   */
  fun saveGroup() {
    val validated =
        _uiState.value.copy(
            nameError = if (_uiState.value.name.isBlank()) "Name cannot be empty" else null)
    _uiState.value = validated

    // Abort if validation failed
    if (_uiState.value.nameError != null) {
      return
    }

    viewModelScope.launch {
      _uiState.value = _uiState.value.copy(isSaving = true, saveError = null)
      try {
        // Calculate final member list: current members - removed + newly added
        val currentMemberIds = _uiState.value.currentMemberProfiles.map { it.uid }
        val finalMemberIds =
            (currentMemberIds - _uiState.value.membersToRemove.toSet()) +
                _uiState.value.selectedNewFriendIds

        // Ensure admins are still members (remove admin status if member was removed)
        val finalAdminIds = _uiState.value.adminIds.filter { adminId -> adminId in finalMemberIds }

        val updatedGroup =
            Group(
                gid = _uiState.value.groupId,
                creatorId =
                    "", // Will be preserved by repository (we don't modify creator in edits)
                name = validated.name,
                description = validated.description.ifBlank { null },
                memberIds = finalMemberIds,
                adminIds = finalAdminIds)

        groupsRepository.editGroup(_uiState.value.groupId, updatedGroup)
        _uiState.value = _uiState.value.copy(isSaving = false, saveSuccess = true)
      } catch (e: Exception) {
        _uiState.value = _uiState.value.copy(isSaving = false, saveError = e.message)
      }
    }
  }

  /** Deletes the current group from the repository. */
  fun deleteGroup() {
    val groupId = _uiState.value.groupId
    if (groupId.isBlank()) return

    viewModelScope.launch {
      try {
        groupsRepository.deleteGroup(groupId)
      } catch (e: Exception) {
        _uiState.value = _uiState.value.copy(saveError = e.message)
      }
    }
  }

  /** Updates the search query and filtered friends list. */
  fun onFriendsSearchQueryChanged(newQuery: String) {
    val available = _uiState.value.availableFriendsToAdd
    val filtered =
        if (newQuery.isBlank()) {
          available
        } else {
          available.filter { it.username.contains(newQuery, ignoreCase = true) }
        }

    _uiState.value =
        _uiState.value.copy(friendsSearchQuery = newQuery, filteredAvailableFriends = filtered)
  }

  /**
   * Factory to create EditGroupViewModel with dependencies.
   *
   * @param groupsRepository The GroupsRepository to use (default: Firestore implementation).
   * @param profileRepository The ProfileRepository to use (default: Firestore implementation).
   * @param notificationsRepository The NotificationsRepository to use (default: provided by
   *   NotificationsRepositoryProvider).
   * @param authProvider A function that provides the FirebaseAuth instance (default:
   *   Firebase.auth).
   * @return A ViewModelProvider.Factory that creates EditGroupViewModel instances.
   */
  companion object {
    fun provideFactory(
        groupsRepository: GroupsRepository = GroupsRepositoryFirestore(Firebase.firestore),
        profileRepository: ProfileRepository =
            ProfileRepositoryFirestore(Firebase.firestore, Firebase.storage),
        notificationsRepository: NotificationsRepository =
            NotificationsRepositoryProvider.repository,
        authProvider: () -> FirebaseAuth = { Firebase.auth }
    ): ViewModelProvider.Factory {
      return object : ViewModelProvider.Factory {
        @Suppress("UNCHECKED_CAST")
        override fun <T : ViewModel> create(modelClass: Class<T>): T {
          if (modelClass.isAssignableFrom(EditGroupViewModel::class.java)) {
            return EditGroupViewModel(
                groupsRepository = groupsRepository,
                profileRepository = profileRepository,
                notificationsRepository = notificationsRepository,
                authProvider = authProvider)
                as T
          }
          throw IllegalArgumentException("Unknown ViewModel class $modelClass")
        }
      }
    }
  }
}
