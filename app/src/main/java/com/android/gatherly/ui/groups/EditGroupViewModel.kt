package com.android.gatherly.ui.groups

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.android.gatherly.model.group.Group
import com.android.gatherly.model.group.GroupsRepository
import com.android.gatherly.model.group.GroupsRepositoryFirestore
import com.android.gatherly.model.profile.Profile
import com.android.gatherly.model.profile.ProfileRepository
import com.android.gatherly.model.profile.ProfileRepositoryFirestore
import com.google.firebase.Firebase
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.auth
import com.google.firebase.firestore.firestore
import com.google.firebase.storage.storage
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

// This file was inspired by AddTodoViewModel.kt in this project.
// This file contains code generated by an LLM (Claude.ai).

/**
 * Represents the UI state of the Edit Group screen.
 *
 * Holds the loaded group data, user-entered modifications, validation errors, member management
 * state, and progress flags used by [EditGroupViewModel] to manage the process of editing an
 * existing Group.
 */
data class EditGroupUiState(
    val groupId: String = "",
    val name: String = "",
    val description: String = "",
    val nameError: String? = null,
    val currentMemberProfiles: List<Profile> = emptyList(),
    val adminIds: List<String> = emptyList(),
    val friendsList: List<Profile> = emptyList(),
    val availableFriendsToAdd: List<Profile> = emptyList(),
    val selectedNewFriendIds: List<String> = emptyList(),
    val membersToRemove: List<String> = emptyList(),
    val isLoading: Boolean = false,
    val loadError: String? = null,
    val isSaving: Boolean = false,
    val saveError: String? = null,
    val saveSuccess: Boolean = false
)

/**
 * ViewModel responsible for managing the "Edit Group" screen.
 *
 * Handles loading an existing group, managing member additions/removals, admin promotion/demotion,
 * field validation, and saving updates to the Firestore repository through [GroupsRepository].
 *
 * @param groupsRepository The repository responsible for persisting Group items.
 * @param profileRepository The repository responsible for fetching user profiles and friends.
 */
class EditGroupViewModel(
    private val groupsRepository: GroupsRepository = GroupsRepositoryFirestore(Firebase.firestore),
    private val profileRepository: ProfileRepository =
        ProfileRepositoryFirestore(Firebase.firestore, Firebase.storage),
    private val authProvider: () -> FirebaseAuth = { Firebase.auth }
) : ViewModel() {
  private val _uiState = MutableStateFlow(EditGroupUiState())

  /** Public immutable access to the Edit Group UI state. */
  val uiState: StateFlow<EditGroupUiState> = _uiState.asStateFlow()

  /** Clears the error message in the UI state. */
  fun clearErrorMsg() {
    _uiState.value = _uiState.value.copy(saveError = null, loadError = null)
  }

  /** Clears the save success flag in the UI state. */
  fun clearSaveSuccess() {
    _uiState.value = _uiState.value.copy(saveSuccess = false)
  }

  /**
   * Loads the group with the specified ID and initializes the UI state.
   *
   * Fetches the group data, loads current member profiles, loads the user's friends list, and
   * calculates which friends can be added to the group.
   *
   * @param groupId The ID of the group to edit.
   */
  fun loadGroup(groupId: String) {
    viewModelScope.launch {
      _uiState.value = _uiState.value.copy(isLoading = true, loadError = null)
      try {
        val group = groupsRepository.getGroup(groupId)

        _uiState.value =
            _uiState.value.copy(
                groupId = group.gid,
                name = group.name,
                description = group.description ?: "",
                adminIds = group.adminIds)

        // Load member profiles and friends list in parallel
        loadMemberProfiles(group.memberIds)
        loadFriends(group.memberIds)

        _uiState.value = _uiState.value.copy(isLoading = false)
      } catch (e: Exception) {
        _uiState.value = _uiState.value.copy(isLoading = false, loadError = e.message)
      }
    }
  }

  /**
   * Loads profiles for current group members.
   *
   * @param memberIds List of user IDs who are current members of the group.
   */
  private suspend fun loadMemberProfiles(memberIds: List<String>) {
    try {
      val memberProfiles =
          memberIds.mapNotNull { memberId ->
            try {
              profileRepository.getProfileByUid(memberId)
            } catch (e: Exception) {
              Log.e("EditGroupViewModel", "Failed to fetch profile for $memberId", e)
              null // Skip members that can't be fetched
            }
          }
      _uiState.value = _uiState.value.copy(currentMemberProfiles = memberProfiles)
    } catch (e: Exception) {
      // 'Silently' fail - member profiles are not critical for editing
      Log.e("EditGroupViewModel", "Failed to update member profiles UI state", e)
    }
  }

  /**
   * Loads the current user's friends list and calculates which friends are available to add.
   *
   * Friends who are already members of the group are excluded from the available list.
   *
   * @param currentMemberIds List of user IDs who are current members of the group.
   */
  private suspend fun loadFriends(currentMemberIds: List<String>) {
    try {
      val currentUserId =
          authProvider().currentUser?.uid ?: throw IllegalStateException("No signed in user")
      val currentProfile =
          profileRepository.getProfileByUid(currentUserId)
              ?: throw NoSuchElementException("Current user profile not found")

      val friendProfiles =
          currentProfile.friendUids.mapNotNull { friendId ->
            try {
              profileRepository.getProfileByUid(friendId)
            } catch (e: Exception) {
              Log.e("EditGroupViewModel", "Failed to fetch profile for friend $friendId", e)
              null // Skip friends that can't be fetched
            }
          }
      val currentMemberIdSet = currentMemberIds.toSet()
      val availableFriends = friendProfiles.filter { it.uid !in currentMemberIdSet }
      _uiState.value =
          _uiState.value.copy(
              friendsList = friendProfiles, availableFriendsToAdd = availableFriends)
    } catch (e: Exception) {
      Log.e("EditGroupViewModel", "Failed to load friends list", e)
      // 'Silently' fail - friends list is not critical for basic editing
      _uiState.value =
          _uiState.value.copy(friendsList = emptyList(), availableFriendsToAdd = emptyList())
    }
  }

  /**
   * Updates the name field and validates that it is not blank.
   *
   * @param newValue The new name entered by the user. If blank, a validation error is set.
   */
  fun onNameChanged(newValue: String) {
    _uiState.value =
        _uiState.value.copy(
            name = newValue, nameError = if (newValue.isBlank()) "Name cannot be empty" else null)
  }

  /**
   * Updates the description field.
   *
   * @param newValue The new description entered by the user.
   */
  fun onDescriptionChanged(newValue: String) {
    _uiState.value = _uiState.value.copy(description = newValue)
  }

  /**
   * Toggles the selection of a friend to add to the group.
   *
   * @param friendId The ID of the friend to toggle selection for.
   */
  fun onNewFriendToggled(friendId: String) {
    val currentSelected = _uiState.value.selectedNewFriendIds
    val newSelected =
        if (friendId in currentSelected) {
          currentSelected - friendId
        } else {
          currentSelected + friendId
        }
    _uiState.value = _uiState.value.copy(selectedNewFriendIds = newSelected)
  }

  /**
   * Marks a member for removal from the group.
   *
   * The member will be removed when [saveGroup] is called. If the member is already marked for
   * removal, this call unmarks them.
   *
   * @param memberId The ID of the member to toggle removal for.
   */
  fun onToggleRemoveMember(memberId: String) {
    val currentToRemove = _uiState.value.membersToRemove
    val newToRemove =
        if (memberId in currentToRemove) {
          currentToRemove - memberId
        } else {
          currentToRemove + memberId
        }
    _uiState.value = _uiState.value.copy(membersToRemove = newToRemove)
  }

  /**
   * Toggles the admin status of a group member.
   *
   * If the member is currently an admin, they will be demoted. If they are not an admin, they will
   * be promoted.
   *
   * @param memberId The ID of the member whose admin status to toggle.
   */
  fun onToggleAdmin(memberId: String) {
    val currentAdmins = _uiState.value.adminIds
    val newAdmins =
        if (memberId in currentAdmins) {
          currentAdmins - memberId
        } else {
          currentAdmins + memberId
        }
    _uiState.value = _uiState.value.copy(adminIds = newAdmins)
  }

  /**
   * Attempts to save all modifications to the group.
   *
   * Performs field validation before saving, calculates the final member and admin lists, and
   * updates the group in the repository. Updates the UI state to reflect loading, success, and
   * error states.
   */
  fun saveGroup() {
    val validated =
        _uiState.value.copy(
            nameError = if (_uiState.value.name.isBlank()) "Name cannot be empty" else null)
    _uiState.value = validated

    // Abort if validation failed
    if (_uiState.value.nameError != null) {
      return
    }

    viewModelScope.launch {
      _uiState.value = _uiState.value.copy(isSaving = true, saveError = null)
      try {
        // Calculate final member list: current members - removed + newly added
        val currentMemberIds = _uiState.value.currentMemberProfiles.map { it.uid }
        val finalMemberIds =
            (currentMemberIds - _uiState.value.membersToRemove.toSet()) +
                _uiState.value.selectedNewFriendIds

        // Ensure admins are still members (remove admin status if member was removed)
        val finalAdminIds = _uiState.value.adminIds.filter { adminId -> adminId in finalMemberIds }

        val updatedGroup =
            Group(
                gid = _uiState.value.groupId,
                creatorId =
                    "", // Will be preserved by repository (we don't modify creator in edits)
                name = validated.name,
                description = if (validated.description.isBlank()) null else validated.description,
                memberIds = finalMemberIds,
                adminIds = finalAdminIds)

        groupsRepository.editGroup(_uiState.value.groupId, updatedGroup)
        _uiState.value = _uiState.value.copy(isSaving = false, saveSuccess = true)
      } catch (e: Exception) {
        _uiState.value = _uiState.value.copy(isSaving = false, saveError = e.message)
      }
    }
  }
}
