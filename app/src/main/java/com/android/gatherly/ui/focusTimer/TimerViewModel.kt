package com.android.gatherly.ui.focusTimer

// This file contains code generated by an LLM (ChatGPT)

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.android.gatherly.model.focusSession.FocusSession
import com.android.gatherly.model.focusSession.FocusSessionsRepository
import com.android.gatherly.model.focusSession.FocusSessionsRepositoryProvider
import com.android.gatherly.model.points.Points
import com.android.gatherly.model.points.PointsRepository
import com.android.gatherly.model.points.PointsRepositoryFirestore
import com.android.gatherly.model.points.PointsSource
import com.android.gatherly.model.profile.ProfileRepository
import com.android.gatherly.model.profile.ProfileRepositoryProvider
import com.android.gatherly.model.profile.ProfileStatus
import com.android.gatherly.model.profile.UserStatusManager
import com.android.gatherly.model.todo.ToDo
import com.android.gatherly.model.todo.ToDosRepository
import com.android.gatherly.model.todo.ToDosRepositoryProvider
import com.android.gatherly.utils.updateFocusPoints
import com.google.firebase.Firebase
import com.google.firebase.Timestamp
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.auth
import com.google.firebase.firestore.firestore
import java.util.Timer
import kotlin.concurrent.fixedRateTimer
import kotlin.math.floor
import kotlin.math.max
import kotlin.time.Duration
import kotlin.time.Duration.Companion.seconds
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

/**
 * UI state for the Timer's ViewModel
 *
 * @param plannedDuration The total planned duration for the timer
 * @param remainingTime The remaining time left on the timer
 * @param hours The hours part of the timer display (formatted as "HH")
 * @param minutes The minutes part of the timer display (formatted as "MM")
 * @param seconds The seconds part of the timer display (formatted as "SS")
 * @param isPaused Indicates whether the timer is currently paused
 * @param isStarted Indicates whether the timer has been started
 * @param errorMsg An optional error message to be displayed in the UI
 * @param linkedTodo The ToDo item linked to this timer session, if any
 * @param allTodos A list of all ToDo items available for linking
 */
data class TimerState(
    val plannedDuration: Duration = Duration.ZERO,
    val remainingTime: Duration = Duration.ZERO,
    val hours: String = "",
    val minutes: String = "",
    val seconds: String = "",
    val isPaused: Boolean = false,
    val isStarted: Boolean = false,
    val errorMsg: String? = null,
    val linkedTodo: ToDo? = null,
    val allTodos: List<ToDo> = emptyList(),
    val pointsGained: Double = 0.0
)

/**
 * ViewModel that manages a focus countdown timer
 *
 * @param todoRepository The repository used to fetch and manage ToDos
 * @param userStatusManager Updates the current user's online/offline status.
 */
class TimerViewModel(
    private val todoRepository: ToDosRepository = ToDosRepositoryProvider.repository,
    private val pointsRepository: PointsRepository = PointsRepositoryFirestore(Firebase.firestore),
    private val profileRepository: ProfileRepository = ProfileRepositoryProvider.repository,
    private val userStatusManager: UserStatusManager = UserStatusManager(),
    private val focusSessionsRepository: FocusSessionsRepository =
        FocusSessionsRepositoryProvider.repository,
    private val authProvider: () -> FirebaseAuth = { Firebase.auth }
) : ViewModel() {

  private val _uiState = MutableStateFlow(TimerState())
  val uiState: StateFlow<TimerState> = _uiState.asStateFlow()

  private var startedAt: Timestamp? = null
  private var elapsedTime: Duration = Duration.ZERO
  private var timer: Timer? = null

  // This is different from startedAt: it marks when the session was created, whereas startedAt
  // resets on pause/resume
  private var sessionStartedAt: Timestamp? = null
  private var currentSessionId: String? = null

  init {
    getAllTodos()
  }

  /** Fetches all todos from the repository and updates the UI state. */
  fun getAllTodos() {
    viewModelScope.launch {
      _uiState.value = _uiState.value.copy()
      try {
        val todos = todoRepository.getAllTodos()
        _uiState.value = _uiState.value.copy(allTodos = todos)
      } catch (e: Exception) {
        setError("Failed to load todos")
      }
    }
  }

  // Functions to update the UI state ------------------------------------------------
  /**
   * Sets the hours for the timer after validating the input.
   *
   * @param hours The hours input as a string
   */
  fun setHours(hours: String) {
    if (!hours.isEmpty()) {
      val h = hours.toIntOrNull() ?: return setError("Invalid hour : Use numbers like 0–23 hours")
      if (h !in 0..23) return setError("Invalid hour : Use numbers like 0–23 hours")
    }
    _uiState.value = _uiState.value.copy(hours = hours)
  }

  /**
   * Sets the minutes for the timer after validating the input.
   *
   * @param minutes The minutes input as a string
   */
  fun setMinutes(minutes: String) {
    if (!minutes.isEmpty()) {
      val m =
          minutes.toIntOrNull()
              ?: return setError("Invalid minutes : Use numbers like 0–59 minutes")
      if (m !in 0..59) return setError("Invalid minutes : Use numbers like 0–59 minutes")
    }
    _uiState.value = _uiState.value.copy(minutes = minutes)
  }

  /**
   * Sets the seconds for the timer after validating the input.
   *
   * @param seconds The seconds input as a string
   */
  fun setSeconds(seconds: String) {
    if (!seconds.isEmpty()) {
      val s =
          seconds.toIntOrNull()
              ?: return setError("Invalid seconds : Use numbers like 0–59 seconds")
      if (s !in 0..59) return setError("Invalid seconds : Use numbers like 0–59 seconds")
    }
    _uiState.value = _uiState.value.copy(seconds = seconds)
  }
  // ---------------------------------------------------------------------------------------

  /** Starts or resumes the timer based on the current state. */
  fun startTimer() {
    if (!_uiState.value.isStarted) {
      if (_uiState.value.hours.isEmpty()) _uiState.value = uiState.value.copy(hours = "00")
      if (_uiState.value.minutes.isEmpty()) _uiState.value = uiState.value.copy(minutes = "00")
      if (_uiState.value.seconds.isEmpty()) _uiState.value = uiState.value.copy(seconds = "00")
    }

    // If resuming from pause
    if (_uiState.value.isStarted && _uiState.value.isPaused) {
      startedAt = Timestamp.now()
      _uiState.value = _uiState.value.copy(isPaused = false, errorMsg = null)
      startTicking()
      return
    }

    // If starting
    val planned =
        parsePlannedDuration(_uiState.value.hours, _uiState.value.minutes, _uiState.value.seconds)
            ?: return

    if (planned <= Duration.ZERO) {
      return setError("Planned duration must be greater than 0.")
    }

    val sessionId = focusSessionsRepository.getNewId()
    currentSessionId = sessionId
    elapsedTime = Duration.ZERO
    startedAt = Timestamp.now()
    sessionStartedAt = startedAt

    _uiState.value =
        _uiState.value.copy(
            plannedDuration = planned,
            remainingTime = planned,
            isStarted = true,
            isPaused = false,
            errorMsg = null)

    viewModelScope.launch { userStatusManager.setStatus(ProfileStatus.FOCUSED) }

    val newSession =
        FocusSession(
            focusSessionId = sessionId,
            creatorId = "", // Will be overwritten by repository using currentUserId()
            linkedTodoId = _uiState.value.linkedTodo?.uid,
            duration = Duration.ZERO,
            startedAt = sessionStartedAt,
            endedAt = null)

    viewModelScope.launch {
      try {
        focusSessionsRepository.addFocusSession(newSession)
        _uiState.value =
            _uiState.value.copy(
                plannedDuration = planned,
                remainingTime = planned,
                isStarted = true,
                isPaused = false,
                errorMsg = null)
      } catch (_: Exception) {
        setError("Failed to create focus session")
      }
    }

    updateClock(planned)
    startTicking()
  }

  /** Ends the timer and resets the state. */
  fun endTimer() {
    _uiState.value = _uiState.value.copy(pointsGained = 0.0)

    val state = _uiState.value
    if (!state.isStarted) return

    val now = Timestamp.now()
    val sinceStart =
        if (!state.isPaused) startedAt?.let { difference(it, now) } ?: Duration.ZERO
        else Duration.ZERO
    elapsedTime += sinceStart
    val sessionId = currentSessionId ?: return
    val started = sessionStartedAt ?: return
    val endedAt = Timestamp.now()
    val totalDurationSeconds = (elapsedTime.inWholeSeconds).coerceAtLeast(0)

    cancelTicking()
    startedAt = null
    _uiState.value =
        state.copy(
            remainingTime = Duration.ZERO, isStarted = false, isPaused = false, errorMsg = null)
    viewModelScope.launch { userStatusManager.setStatus(ProfileStatus.ONLINE) }
    updateClock(Duration.ZERO)
    val updatedSession =
        FocusSession(
            focusSessionId = sessionId,
            creatorId = "", // repo will overwrite
            linkedTodoId = state.linkedTodo?.uid,
            duration = totalDurationSeconds.seconds,
            startedAt = started,
            endedAt = endedAt)
    viewModelScope.launch {
      try {
        focusSessionsRepository.updateFocusSession(sessionId, updatedSession)
      } catch (_: Exception) {
        setError("Failed to finalize focus session")
      }
    }

    // add focus points to profile
    viewModelScope.launch {
      try {
        val points =
            Points(
                userId = authProvider().currentUser?.uid!!,
                obtained = _uiState.value.pointsGained,
                reason = PointsSource.Timer(elapsedTime.inWholeMinutes.toInt()),
                dateObtained = Timestamp.now())
        updateFocusPoints(pointsRepository, profileRepository, points)
      } catch (_: Exception) {
        setError("Failed to add focus points to profile")
      }
    }

    resetTimer()
  }

  /** Pauses the timer if it is currently running. */
  fun pauseTimer() {
    val state = _uiState.value
    if (!state.isStarted || state.isPaused) return

    val now = Timestamp.now()
    val sinceStart = startedAt?.let { difference(it, now) } ?: Duration.ZERO
    elapsedTime += sinceStart
    startedAt = null

    val remaining = max(0, (state.plannedDuration - elapsedTime).inWholeSeconds).seconds
    cancelTicking()
    _uiState.value = state.copy(remainingTime = remaining, isPaused = true, errorMsg = null)
    viewModelScope.launch { userStatusManager.setStatus(ProfileStatus.ONLINE) }
    updateClock(remaining)
  }

  /** Resets the timer. */
  fun resetTimer() {
    cancelTicking()
    startedAt = null
    currentSessionId = null
    sessionStartedAt = null
    timer = null
    elapsedTime = Duration.ZERO
    _uiState.value =
        _uiState.value.copy(
            plannedDuration = Duration.ZERO,
            remainingTime = Duration.ZERO,
            isStarted = false,
            isPaused = false,
            errorMsg = null)
    updateClock(Duration.ZERO)
  }

  /** Starts the ticking mechanism that updates the timer every second. */
  private fun startTicking() {
    cancelTicking()
    timer =
        fixedRateTimer(name = "focus-timer", daemon = true, period = 1000L, initialDelay = 1000L) {
          val state = _uiState.value
          if (!state.isStarted || state.isPaused) return@fixedRateTimer

          val now = Timestamp.now()
          val sinceStart = startedAt?.let { difference(it, now) } ?: Duration.ZERO
          val elapsed = elapsedTime + sinceStart
          val remaining = max(0, (state.plannedDuration - elapsed).inWholeSeconds).seconds

          // if we are on the minute, gain a focus depending on the time that has passed (every 5
          // minutes, the points gained increases by 5%)
          if (elapsed.inWholeSeconds % 60 == 0L) {
            val bonus = 1 + floor(elapsed.inWholeMinutes / 5.0) * 0.05
            _uiState.value = _uiState.value.copy(pointsGained = _uiState.value.pointsGained + bonus)
          }

          _uiState.value = state.copy(remainingTime = remaining)
          updateClock(remaining)

          if (remaining <= Duration.ZERO) {
            elapsedTime = state.plannedDuration
            _uiState.value = _uiState.value.copy(isStarted = false, isPaused = false)
            updateClock(Duration.ZERO)
            viewModelScope.launch { userStatusManager.setStatus(ProfileStatus.ONLINE) }
            endTimer()
          }
        }
  }

  /**
   * Parses the planned duration from hours, minutes, and seconds strings.
   *
   * @param h The hours input as a string
   * @param m The minutes input as a string
   * @param s The seconds input as a string
   * @return The total duration, or null if parsing fails
   */
  private fun parsePlannedDuration(h: String, m: String, s: String): Duration? {
    val hh = h.toIntOrNull() ?: return null
    val mm = m.toIntOrNull() ?: return null
    val ss = s.toIntOrNull() ?: return null
    if (hh !in 0..23 || mm !in 0..59 || ss !in 0..59) return null
    val total = hh * 3600L + mm * 60L + ss
    return total.seconds
  }

  /** Cancels the ticking timer if it is running. */
  private fun cancelTicking() {
    timer?.cancel()
    timer = null
  }

  /**
   * Calculates the difference between two Timestamps and returns it as a Duration.
   *
   * @param start The starting Timestamp
   * @param end The ending Timestamp
   * @return The duration between the two timestamps
   */
  private fun difference(start: Timestamp, end: Timestamp): Duration {
    val ms =
        (end.seconds - start.seconds) * 1000L + (end.nanoseconds - start.nanoseconds) / 1_000_000L
    return (ms / 1000).seconds
  }

  /**
   * Sets an error message in the UI state.
   *
   * @param msg The error message to be displayed
   */
  fun setError(msg: String) {
    _uiState.value = _uiState.value.copy(errorMsg = msg)
  }

  /** Clears any existing error message in the UI state. */
  fun clearError() {
    _uiState.value = _uiState.value.copy(errorMsg = null)
  }

  /**
   * Links or unlinks a ToDo item to/from the current timer session.
   *
   * @param todo The ToDo item to link or unlink
   */
  fun linkToDo(todo: ToDo?) {
    if (todo == _uiState.value.linkedTodo) {
      _uiState.value = _uiState.value.copy(linkedTodo = null)
      return
    }
    _uiState.value = _uiState.value.copy(linkedTodo = todo)
  }

  /**
   * Updates the clock display based on the remaining time.
   *
   * @param remainingTime The remaining time to display
   */
  private fun updateClock(remainingTime: Duration) {
    val total = remainingTime.inWholeSeconds
    val h = total / 3600
    val m = (total % 3600) / 60
    val s = total % 60

    /**
     * Update the UI state with formatted time values : only 2 digits per metric and adding 0 if
     * only 1 digit like 01:15
     */
    _uiState.value =
        _uiState.value.copy(
            hours = h.toString().padStart(2, '0'),
            minutes = m.toString().padStart(2, '0'),
            seconds = s.toString().padStart(2, '0'))
  }

  /** Cleans up resources when the ViewModel is cleared. */
  override fun onCleared() {
    cancelTicking()
    super.onCleared()
  }
}
