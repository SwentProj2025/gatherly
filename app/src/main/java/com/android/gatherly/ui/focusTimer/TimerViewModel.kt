package com.android.gatherly.ui.focusTimer

// This file contains code generated by an LLM (ChatGPT)

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.android.gatherly.model.todo.ToDo
import com.android.gatherly.model.todo.ToDosRepository
import com.android.gatherly.model.todo.ToDosRepositoryProvider
import com.google.firebase.Timestamp
import java.util.Timer
import kotlin.concurrent.fixedRateTimer
import kotlin.math.max
import kotlin.time.Duration
import kotlin.time.Duration.Companion.seconds
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

/**
 * UI state for the Timer's ViewModel
 *
 * @param plannedDuration The total planned duration for the timer
 * @param remainingTime The remaining time left on the timer
 * @param hours The hours part of the timer display (formatted as "HH")
 * @param minutes The minutes part of the timer display (formatted as "MM")
 * @param seconds The seconds part of the timer display (formatted as "SS")
 * @param isPaused Indicates whether the timer is currently paused
 * @param isStarted Indicates whether the timer has been started
 * @param errorMsg An optional error message to be displayed in the UI
 * @param linkedTodo The ToDo item linked to this timer session, if any
 * @param allTodos A list of all ToDo items available for linking
 */
data class TimerState(
    val plannedDuration: Duration = Duration.ZERO,
    val remainingTime: Duration = Duration.ZERO,
    val hours: String = "00",
    val minutes: String = "00",
    val seconds: String = "00",
    val isPaused: Boolean = false,
    val isStarted: Boolean = false,
    val errorMsg: String? = null,
    val linkedTodo: ToDo? = null,
    val allTodos: List<ToDo> = emptyList(),
)

/**
 * ViewModel that manages a focus countdown timer
 *
 * @param todoRepository The repository used to fetch and manage ToDos
 */
class TimerViewModel(
    private val todoRepository: ToDosRepository = ToDosRepositoryProvider.repository
) : ViewModel() {

  private val _uiState = MutableStateFlow(TimerState())
  val uiState: StateFlow<TimerState> = _uiState.asStateFlow()

  private var startedAt: Timestamp? = null
  private var elapsedTime: Duration = Duration.ZERO
  private var timer: Timer? = null

  init {
    getAllTodos()
  }

  /** Fetches all todos from the repository and updates the UI state. */
  fun getAllTodos() {
    viewModelScope.launch {
      _uiState.value = _uiState.value.copy()
      try {
        val todos = todoRepository.getAllTodos()
        _uiState.value = _uiState.value.copy(allTodos = todos)
      } catch (e: Exception) {
        setError("Failed to load todos")
      }
    }
  }

  // Functions to update the UI state ------------------------------------------------
  /**
   * Sets the hours for the timer after validating the input.
   *
   * @param hours The hours input as a string
   */
  fun setHours(hours: String) {
    val h = hours.toIntOrNull() ?: return setError("Invalid hour : Use numbers like 0–23 hours")
    if (h !in 0..23) return setError("Invalid hour : Use numbers like 0–23 hours")
    _uiState.value = _uiState.value.copy(hours = hours)
  }

  /**
   * Sets the minutes for the timer after validating the input.
   *
   * @param minutes The minutes input as a string
   */
  fun setMinutes(minutes: String) {
    val m =
        minutes.toIntOrNull() ?: return setError("Invalid minutes : Use numbers like 0–59 minutes")
    if (m !in 0..59) return setError("Invalid minutes : Use numbers like 0–59 minutes")
    _uiState.value = _uiState.value.copy(minutes = minutes)
  }

  /**
   * Sets the seconds for the timer after validating the input.
   *
   * @param seconds The seconds input as a string
   */
  fun setSeconds(seconds: String) {
    val s =
        seconds.toIntOrNull() ?: return setError("Invalid seconds : Use numbers like 0–59 seconds")
    if (s !in 0..59) return setError("Invalid seconds : Use numbers like 0–59 seconds")
    _uiState.value = _uiState.value.copy(seconds = seconds)
  }
  // ---------------------------------------------------------------------------------------

  /** Starts or resumes the timer based on the current state. */
  fun startTimer() {
    // If resuming from pause
    if (_uiState.value.isStarted && _uiState.value.isPaused) {
      startedAt = Timestamp.now()
      _uiState.value = _uiState.value.copy(isPaused = false, errorMsg = null)
      startTicking()
      return
    }

    // If starting
    val planned =
        parsePlannedDuration(_uiState.value.hours, _uiState.value.minutes, _uiState.value.seconds)
            ?: return

    if (planned <= Duration.ZERO) {
      return setError("Planned duration must be greater than 0.")
    }

    elapsedTime = Duration.ZERO
    startedAt = Timestamp.now()

    _uiState.value =
        _uiState.value.copy(
            plannedDuration = planned,
            remainingTime = planned,
            isStarted = true,
            isPaused = false,
            errorMsg = null)
    updateClock(planned)
    startTicking()
  }

  /** Ends the timer and resets the state. */
  fun endTimer() {
    val state = _uiState.value
    if (!state.isStarted) return

    val now = Timestamp.now()
    val sinceStart =
        if (!state.isPaused) startedAt?.let { difference(it, now) } ?: Duration.ZERO
        else Duration.ZERO
    elapsedTime += sinceStart

    cancelTicking()
    startedAt = null
    _uiState.value =
        state.copy(
            remainingTime = Duration.ZERO, isStarted = false, isPaused = false, errorMsg = null)
    updateClock(Duration.ZERO)
  }

  /** Pauses the timer if it is currently running. */
  fun pauseTimer() {
    val state = _uiState.value
    if (!state.isStarted || state.isPaused) return

    val now = Timestamp.now()
    val sinceStart = startedAt?.let { difference(it, now) } ?: Duration.ZERO
    elapsedTime += sinceStart
    startedAt = null

    val remaining = max(0, (state.plannedDuration - elapsedTime).inWholeSeconds).seconds
    cancelTicking()
    _uiState.value = state.copy(remainingTime = remaining, isPaused = true, errorMsg = null)
    updateClock(remaining)
  }

  /** Resets the timer display to 00:00:00. */
  fun resetTimerTime() {
    updateClock(Duration.ZERO)
  }

  /** Starts the ticking mechanism that updates the timer every second. */
  private fun startTicking() {
    cancelTicking()
    timer =
        fixedRateTimer(name = "focus-timer", daemon = true, period = 1000L, initialDelay = 1000L) {
          val state = _uiState.value
          if (!state.isStarted || state.isPaused) return@fixedRateTimer

          val now = Timestamp.now()
          val sinceStart = startedAt?.let { difference(it, now) } ?: Duration.ZERO
          val elapsed = elapsedTime + sinceStart
          val remaining = max(0, (state.plannedDuration - elapsed).inWholeSeconds).seconds

          _uiState.value = state.copy(remainingTime = remaining)
          updateClock(remaining)

          if (remaining <= Duration.ZERO) {
            cancelTicking()
            startedAt = null
            elapsedTime = state.plannedDuration
            _uiState.value = _uiState.value.copy(isStarted = false, isPaused = false)
            updateClock(Duration.ZERO)
          }
        }
  }

  /**
   * Parses the planned duration from hours, minutes, and seconds strings.
   *
   * @param h The hours input as a string
   * @param m The minutes input as a string
   * @param s The seconds input as a string
   * @return The total duration, or null if parsing fails
   */
  private fun parsePlannedDuration(h: String, m: String, s: String): Duration? {
    val hh = h.toIntOrNull() ?: return null
    val mm = m.toIntOrNull() ?: return null
    val ss = s.toIntOrNull() ?: return null
    if (hh !in 0..23 || mm !in 0..59 || ss !in 0..59) return null
    val total = hh * 3600L + mm * 60L + ss
    return total.seconds
  }

  /** Cancels the ticking timer if it is running. */
  private fun cancelTicking() {
    timer?.cancel()
    timer = null
  }

  /**
   * Calculates the difference between two Timestamps and returns it as a Duration.
   *
   * @param start The starting Timestamp
   * @param end The ending Timestamp
   * @return The duration between the two timestamps
   */
  private fun difference(start: Timestamp, end: Timestamp): Duration {
    val ms =
        (end.seconds - start.seconds) * 1000L + (end.nanoseconds - start.nanoseconds) / 1_000_000L
    return (ms / 1000).seconds
  }

  /**
   * Sets an error message in the UI state.
   *
   * @param msg The error message to be displayed
   */
  fun setError(msg: String) {
    _uiState.value = _uiState.value.copy(errorMsg = msg)
  }

  /** Clears any existing error message in the UI state. */
  fun clearError() {
    _uiState.value = _uiState.value.copy(errorMsg = null)
  }

  /**
   * Links or unlinks a ToDo item to/from the current timer session.
   *
   * @param todo The ToDo item to link or unlink
   */
  fun linkToDo(todo: ToDo?) {
    if (todo == _uiState.value.linkedTodo) {
      _uiState.value = _uiState.value.copy(linkedTodo = null)
      return
    }
    _uiState.value = _uiState.value.copy(linkedTodo = todo)
  }

  /**
   * Updates the clock display based on the remaining time.
   *
   * @param remainingTime The remaining time to display
   */
  private fun updateClock(remainingTime: Duration) {
    val total = remainingTime.inWholeSeconds
    val h = total / 3600
    val m = (total % 3600) / 60
    val s = total % 60

    /**
     * Update the UI state with formatted time values : only 2 digits per metric and adding 0 if
     * only 1 digit like 01:15
     */
    _uiState.value =
        _uiState.value.copy(
            hours = h.toString().padStart(2, '0'),
            minutes = m.toString().padStart(2, '0'),
            seconds = s.toString().padStart(2, '0'))
  }
}
