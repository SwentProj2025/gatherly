package com.android.gatherly.model.notification

import com.google.firebase.auth.ktx.auth
import com.google.firebase.firestore.CollectionReference
import com.google.firebase.firestore.DocumentSnapshot
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.Query
import com.google.firebase.ktx.Firebase
import kotlinx.coroutines.tasks.await

// This class contains code generated by an LLM (Claude.ai, GitHub Copilot).

/**
 * Firestore-backed implementation of [NotificationsRepository].
 *
 * Notifications are stored under: users/{userId}/notifications/{notificationId}
 */
class NotificationsRepositoryFirestore(private val db: FirebaseFirestore) :
    NotificationsRepository {

  /** Reference to the "notifications" collection of the user with uid [userId]. */
  private fun notificationsCollection(userId: String = currentUserId()): CollectionReference {
    return db.collection("users").document(userId).collection("notifications")
  }
  /**
   * The UID of the currently authenticated user.
   *
   * @throws IllegalStateException if no user is currently signed in.
   */
  private fun currentUserId(): String {
    return Firebase.auth.currentUser?.uid ?: throw IllegalStateException("No signed in user")
  }

  override fun getNewId(): String {
    return notificationsCollection().document().id
  }

  /**
   * Retrieves all notifications addressed to the given user.
   *
   * Notifications are returned in chronological order (oldest first), based on their
   * [Notification.emissionTime].
   *
   * @param userId UID of the user whose notifications should be retrieved.
   * @return A list of notifications for the specified user.
   * @throws SecurityException if attempting to fetch notifications for a user other than the
   *   currently signed-in one.
   */
  override suspend fun getUserNotifications(userId: String): List<Notification> {
    if (userId != currentUserId()) {
      throw SecurityException("Can only fetch notifications for the current user")
    }
    val querySnapshot =
        notificationsCollection(userId)
            .orderBy("emissionTime", Query.Direction.ASCENDING)
            .get()
            .await()
    return querySnapshot.documents.mapNotNull { doc -> snapshotToNotification(doc) }
  }

  override suspend fun getNotification(notificationId: String): Notification {
    val doc = notificationsCollection().document(notificationId).get().await()
    return snapshotToNotification(doc)
        ?: throw NoSuchElementException("Notification with ID $notificationId not found")
  }

  override suspend fun deleteNotification(notificationId: String) {
    getNotification(notificationId) // Verify it exists and belongs to current user
    notificationsCollection().document(notificationId).delete().await()
  }

  /**
   * Adds a new notification to the repository.
   *
   * @param notification The notification to add.
   * @throws IllegalArgumentException if the notification has an empty recipientId.
   */
  override suspend fun addNotification(notification: Notification) {
    require(notification.recipientId.isNotEmpty()) {
      "Notification can't have an empty recipientId"
    }
    notificationsCollection(notification.recipientId)
        .document(notification.id)
        .set(notificationToMap(notification))
        .await()
  }

  override suspend fun markAsRead(notificationId: String) {
    val existing = getNotification(notificationId)
    if (existing.wasRead) return // Nothing to do
    notificationsCollection().document(notificationId).update("wasRead", true).await()
  }

  /**
   * Converts a Firestore [DocumentSnapshot] into a [Notification].
   *
   * Returns `null` if required fields are missing or invalid.
   */
  private fun snapshotToNotification(doc: DocumentSnapshot): Notification? {
    val id = doc.getString("id") ?: return null
    val typeString = doc.getString("type") ?: return null
    val type =
        try {
          NotificationType.valueOf(typeString)
        } catch (e: IllegalArgumentException) {
          return null
        }
    val emissionTime = doc.getTimestamp("emissionTime") ?: return null
    val wasRead = doc.getBoolean("wasRead") ?: return null
    val relatedEntityId = doc.getString("relatedEntityId")
    val recipientId = doc.getString("recipientId") ?: return null
    val senderId = doc.getString("senderId")
    return Notification(
        id = id,
        type = type,
        emissionTime = emissionTime,
        senderId = senderId,
        relatedEntityId = relatedEntityId,
        recipientId = recipientId,
        wasRead = wasRead)
  }

  /** Converts a [Notification] into a Firestore-compatible map. */
  private fun notificationToMap(notification: Notification): Map<String, Any?> {
    return mapOf(
        "id" to notification.id,
        "type" to notification.type.name,
        "emissionTime" to notification.emissionTime,
        "senderId" to notification.senderId,
        "relatedEntityId" to notification.relatedEntityId,
        "recipientId" to notification.recipientId,
        "wasRead" to notification.wasRead)
  }
}
