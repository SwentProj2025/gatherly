package com.android.gatherly.model.notification

import com.google.firebase.auth.ktx.auth
import com.google.firebase.firestore.DocumentSnapshot
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.Query
import com.google.firebase.ktx.Firebase
import kotlinx.coroutines.tasks.await

// This class contains code generated by an LLM (Claude.ai, GitHub Copilot).

class NotificationsRepositoryFirestore(private val db: FirebaseFirestore) :
    NotificationsRepository {

  /**
   * Returns the user ID of the currently signed-in user, or throws an exception if no user is
   * signed in.
   */
  private fun currentUserId(): String {
    return Firebase.auth.currentUser?.uid ?: throw IllegalStateException("No signed in user")
  }

  /** Returns a new unique ID for a notification. */
  override fun getNewId(): String {
    return db.collection("users")
        .document(currentUserId())
        .collection("notifications")
        .document()
        .id
  }

  override suspend fun getUserNotifications(userId: String): List<Notification> {
    if (userId != currentUserId()) {
      throw SecurityException("Can only fetch notifications for the current user")
    }
    val querySnapshot =
        db.collection("users")
            .document(userId)
            .collection("notifications")
            .orderBy("emissionTime", Query.Direction.DESCENDING)
            .get()
            .await()
    return querySnapshot.documents.mapNotNull { doc -> snapshotToNotification(doc) }
  }

  override suspend fun getNotification(notificationId: String): Notification {
    val doc =
        db.collection("users")
            .document(currentUserId())
            .collection("notifications")
            .document(notificationId)
            .get()
            .await()
    return snapshotToNotification(doc)
        ?: throw NoSuchElementException("Notification with ID $notificationId not found")
  }

  override suspend fun deleteNotification(notificationId: String) {
    getNotification(notificationId) // Verify it exists and belongs to current user
    db.collection("users")
        .document(currentUserId())
        .collection("notifications")
        .document(notificationId)
        .delete()
        .await()
  }

  override suspend fun addNotification(notification: Notification) {
    if (notification.recipientId.isEmpty()) {
      throw IllegalArgumentException("Notification must have a valid recipientId")
    }
    db.collection("users")
        .document(notification.recipientId)
        .collection("notifications")
        .document(notification.id)
        .set(notificationToMap(notification))
        .await()
  }

  override suspend fun markAsRead(notificationId: String) {
    val existing = getNotification(notificationId)
    if (existing.wasRead) return // Nothing to do
    db.collection("users")
        .document(currentUserId())
        .collection("notifications")
        .document(notificationId)
        .update("wasRead", true)
        .await()
  }

  /** Converts a Firestore [DocumentSnapshot] into a [Notification] object. */
  private fun snapshotToNotification(doc: DocumentSnapshot): Notification? {
    val id = doc.getString("id") ?: return null
    val typeString = doc.getString("type") ?: return null
    val type =
        try {
          NotificationType.valueOf(typeString)
        } catch (e: IllegalArgumentException) {
          return null
        }
    val emissionTime = doc.getTimestamp("emissionTime") ?: return null
    val wasRead = doc.getBoolean("wasRead") ?: return null
    val relatedEntityId = doc.getString("relatedEntityId")
    val recipientId = doc.getString("recipientId") ?: return null
    val senderId = doc.getString("senderId")
    return Notification(
        id = id,
        type = type,
        emissionTime = emissionTime,
        senderId = senderId,
        relatedEntityId = relatedEntityId,
        recipientId = recipientId,
        wasRead = wasRead)
  }

  /** Converts a [Notification] into a Firestore-compatible map. */
  private fun notificationToMap(notification: Notification): Map<String, Any?> {
    return mapOf(
        "id" to notification.id,
        "type" to notification.type.name,
        "emissionTime" to notification.emissionTime,
        "senderId" to notification.senderId,
        "relatedEntityId" to notification.relatedEntityId,
        "recipientId" to notification.recipientId,
        "wasRead" to notification.wasRead)
  }
}
