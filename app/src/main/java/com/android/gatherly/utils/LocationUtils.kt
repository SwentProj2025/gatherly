package com.android.gatherly.utils

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.location.Location
import android.os.Looper
import androidx.core.content.ContextCompat
import com.google.android.gms.location.FusedLocationProviderClient
import com.google.android.gms.location.LocationCallback
import com.google.android.gms.location.LocationRequest
import com.google.android.gms.location.LocationResult
import com.google.android.gms.location.Priority
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.callbackFlow

// This file contains code generated by an LLM (Claude.ai).

/** Utility functions for the Map's location features. */
/**
 * Note that the Location objects used here are from android.location.Location, not the custom
 * Location data class defined in the project.
 */

/** Creates a LocationRequest with high accuracy and a 10-second interval. */
fun createLocationRequest(): LocationRequest {
  return LocationRequest.Builder(10000L).setPriority(Priority.PRIORITY_HIGH_ACCURACY).build()
}

/**
 * Extension function to convert location updates from FusedLocationProviderClient into a Kotlin
 * Flow of Location objects.
 *
 * @param context The context used to check for location permissions.
 * @return A Flow that emits Location updates.
 */
fun FusedLocationProviderClient.locationFlow(context: Context) =
    callbackFlow<Location> {
      // Runtime check: ensure location permission is granted
      if (ContextCompat.checkSelfPermission(context, Manifest.permission.ACCESS_FINE_LOCATION) !=
          PackageManager.PERMISSION_GRANTED) {
        close(SecurityException("Location permission not granted"))
        return@callbackFlow
      }

      val callback =
          object : LocationCallback() {
            override fun onLocationResult(result: LocationResult) {
              for (location in result.locations) {
                trySend(location)
              }
            }
          }

      // The permission check is done above, so we can suppress the warning
      // that would show up otherwise
      @Suppress("MissingPermission")
      requestLocationUpdates(createLocationRequest(), callback, Looper.getMainLooper())
          .addOnFailureListener { e -> close(e) }

      awaitClose { removeLocationUpdates(callback) }
    }
