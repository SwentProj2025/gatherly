package com.android.gatherly.utils

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.location.Location
import android.os.Looper
import androidx.core.content.ContextCompat
import com.google.android.gms.location.FusedLocationProviderClient
import com.google.android.gms.location.LocationCallback
import com.google.android.gms.location.LocationRequest
import com.google.android.gms.location.LocationResult
import com.google.android.gms.location.Priority
import kotlin.math.atan2
import kotlin.math.cos
import kotlin.math.sin
import kotlin.math.sqrt
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.callbackFlow

// This file contains code generated by an LLM (Claude.ai).

/**
 * Utility functions for location services.
 *
 * Provides permission-aware location updates via Kotlin Flow, using Google Play Services'
 * FusedLocationProviderClient for battery-efficient location tracking.
 */

/**
 * Creates a LocationRequest configured for high-accuracy location updates.
 *
 * @return A LocationRequest with 10-second update interval (10000ms) and high accuracy priority.
 */
fun createLocationRequest(): LocationRequest {
  return LocationRequest.Builder(10000L).setPriority(Priority.PRIORITY_HIGH_ACCURACY).build()
}

/**
 * Converts location updates from FusedLocationProviderClient into a Kotlin Flow.
 *
 * Note: This returns `android.location.Location` objects, not the custom `Location` data class
 * defined in the project.
 *
 * @param context The context used to check for location permissions.
 * @return A Flow that emits Location updates. The flow closes with a [SecurityException] if neither
 *   ACCESS_FINE_LOCATION nor ACCESS_COARSE_LOCATION permissions are granted.
 */
fun FusedLocationProviderClient.locationFlow(context: Context) =
    callbackFlow<Location> {
      // Runtime check: ensure location permissions are granted
      val hasFine =
          ContextCompat.checkSelfPermission(context, Manifest.permission.ACCESS_FINE_LOCATION) ==
              PackageManager.PERMISSION_GRANTED
      val hasCoarse =
          ContextCompat.checkSelfPermission(context, Manifest.permission.ACCESS_COARSE_LOCATION) ==
              PackageManager.PERMISSION_GRANTED

      if (!hasFine && !hasCoarse) {
        close(SecurityException("Location permission not granted"))
        return@callbackFlow
      }

      val callback =
          object : LocationCallback() {
            override fun onLocationResult(result: LocationResult) {
              for (location in result.locations) {
                trySend(location)
              }
            }
          }

      // The permission check is done above, so we can suppress the warning
      // that would show up otherwise
      @Suppress("MissingPermission")
      requestLocationUpdates(createLocationRequest(), callback, Looper.getMainLooper())
          .addOnFailureListener { e -> close(e) }

      awaitClose { removeLocationUpdates(callback) }
    }

fun distance(
    location1: com.android.gatherly.model.map.Location,
    location2: com.android.gatherly.model.map.Location
): Double {
  val r = 6371.0

  val lat1Rad = Math.toRadians(location1.latitude)
  val lon1Rad = Math.toRadians(location1.longitude)
  val lat2Rad = Math.toRadians(location2.latitude)
  val lon2Rad = Math.toRadians(location2.longitude)

  val dLat = lat2Rad - lat1Rad
  val dLon = lon2Rad - lon1Rad

  val a =
      sin(dLat / 2) * sin(dLat / 2) + cos(lat1Rad) * cos(lat2Rad) * sin(dLon / 2) * sin(dLon / 2)

  val c = 2 * atan2(sqrt(a), sqrt(1 - a))

  return r * c
}
